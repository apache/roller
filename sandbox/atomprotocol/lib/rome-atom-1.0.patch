Index: src/java/com/sun/syndication/feed/atom/Category.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/atom/Category.java
diff -N src/java/com/sun/syndication/feed/atom/Category.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/atom/Category.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.atom;
+
+import com.sun.syndication.feed.impl.ObjectBean;
+
+import java.io.Serializable;
+
+/**
+ * Bean for category elements of Atom feeds.
+ * <p>
+ * @author Dave Johnson (added for Atom 1.0)
+ */
+public class Category implements Cloneable, Serializable  {
+    
+    private ObjectBean _objBean;
+    
+    private String _term;
+    private String _scheme;  
+    private String _label;
+
+    /**
+     * Default constructor. All properties are set to <b>null</b>.
+     * <p>
+     *
+     */
+    public Category() {
+        _objBean = new ObjectBean(this.getClass(),this);
+    }
+
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public Object clone() throws CloneNotSupportedException {
+        return _objBean.clone();
+    }
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public boolean equals(Object other) {
+        return _objBean.equals(other);
+    }
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public int hashCode() {
+        return _objBean.hashCode();
+    }
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public String toString() {
+        return _objBean.toString();
+    }
+    
+    /** 
+     * Get label for category.
+     * <p>
+     * @return Label for category.
+     */
+    public String getLabel() {
+        return _label;
+    }
+    
+    /**
+     * Set label for category.
+     * <p>
+     * @param Label for category.
+     */
+    public void setLabel(String label) {
+        this._label = label;
+    }
+    
+    /**
+     * Get Scheme URI for category.
+     * <p>
+     * @return Scheme URI for category.
+     */
+    public String getScheme() {
+        return _scheme;
+    }
+    
+    /**
+     * Set scheme URI for category.
+     * <p>
+     * @param Scheme URI for category.
+     */
+    public void setScheme(String scheme) {
+        this._scheme = scheme;
+    }
+    
+    /**
+     * Return term for category.
+     * <p>
+     * @return Term for category.
+     */
+    public String getTerm() {
+        return _term;
+    }
+    
+    /**
+     * Set term for category.
+     * <p>
+     * @param Term for category.
+     */
+    public void setTerm(String term) {
+        this._term = term;
+    }
+}
Index: src/java/com/sun/syndication/feed/synd/SyndLink.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/SyndLink.java
diff -N src/java/com/sun/syndication/feed/synd/SyndLink.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/SyndLink.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd;
+
+/**
+ * Represents a link or enclosure associated with entry.
+ * @author Dave Johnson
+ */
+public interface SyndLink {
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public abstract Object clone() throws CloneNotSupportedException;
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public abstract boolean equals(Object other);
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public abstract int hashCode();
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public abstract String toString();
+
+    /**
+     * Returns the link rel.
+     * <p>
+     * @return the link rel, <b>null</b> if none.
+     *
+     */
+    public abstract String getRel();
+
+    /**
+     * Sets the link rel.
+     * <p>
+     * @param rel the link rel,, <b>null</b> if none.
+     *
+     */
+    public abstract void setRel(String rel);
+
+    /**
+     * Returns the link type.
+     * <p>
+     * @return the link type, <b>null</b> if none.
+     *
+     */
+    public abstract String getType();
+
+    /**
+     * Sets the link type.
+     * <p>
+     * @param type the link type, <b>null</b> if none.
+     *
+     */
+    public abstract void setType(String type);
+
+    /**
+     * Returns the link href.
+     * <p>
+     * @return the link href, <b>null</b> if none.
+     *
+     */
+    public abstract String getHref();
+
+    /**
+     * Sets the link href.
+     * <p>
+     * @param href the link href, <b>null</b> if none.
+     *
+     */
+    public abstract void setHref(String href);
+
+    /**
+     * Returns the link title.
+     * <p>
+     * @return the link title, <b>null</b> if none.
+     *
+     */
+    public abstract String getTitle();
+
+    /**
+     * Sets the link title.
+     * <p>
+     * @param title the link title, <b>null</b> if none.
+     *
+     */
+    public abstract void setTitle(String title);
+
+    /**
+     * Returns the hreflang
+     * <p>
+     * @return Returns the hreflang.
+     */
+    public abstract String getHreflang();
+
+    /**
+     * Set the hreflang
+     * <p>
+     * @param hreflang The hreflang to set.
+     */
+    public abstract void setHreflang(String hreflang);
+
+    /**
+     * Returns the length
+     * <p>
+     * @return Returns the length.
+     */
+    public abstract long getLength();
+
+    /**
+     * Set the length
+     * <p>
+     * @param length The length to set.
+     */
+    public abstract void setLength(long length);
+}
Index: src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java
diff -N src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd;
+
+import com.sun.syndication.feed.impl.ObjectBean;
+
+import java.io.Serializable;
+
+/**
+ * Represents a link or an enclosure.
+ * <p>
+ * @author Alejandro Abdelnur
+ * @author Dave Johnson (updated for Atom 1.0)
+ */
+public class SyndLinkImpl implements Cloneable,Serializable, SyndLink {
+    
+    private ObjectBean _objBean;
+    
+    private String _href;
+    private String _rel;
+    private String _type;
+    private String _hreflang; 
+    private String _title;
+    private long   _length;  
+
+    /**
+     * Default constructor. All properties are set to <b>null</b>.
+     * <p>
+     *
+     */
+    public SyndLinkImpl() {
+        _objBean = new ObjectBean(this.getClass(),this);
+    }
+
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public Object clone() throws CloneNotSupportedException {
+        return _objBean.clone();
+    }
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public boolean equals(Object other) {
+        return _objBean.equals(other);
+    }
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public int hashCode() {
+        return _objBean.hashCode();
+    }
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public String toString() {
+        return _objBean.toString();
+    }
+
+    /**
+     * Returns the link rel.
+     * <p>
+     * @return the link rel, <b>null</b> if none.
+     *
+     */
+    public String getRel() {
+        return _rel;
+    }
+
+    /**
+     * Sets the link rel.
+     * <p>
+     * @param rel the link rel,, <b>null</b> if none.
+     *
+     */
+    public void setRel(String rel) {
+        //TODO add check, ask P@ about the check
+        _rel = rel;
+    }
+
+    /**
+     * Returns the link type.
+     * <p>
+     * @return the link type, <b>null</b> if none.
+     *
+     */
+    public String getType() {
+        return _type;
+    }
+
+    /**
+     * Sets the link type.
+     * <p>
+     * @param type the link type, <b>null</b> if none.
+     *
+     */
+    public void setType(String type) {
+        _type = type;
+    }
+
+    /**
+     * Returns the link href.
+     * <p>
+     * @return the link href, <b>null</b> if none.
+     *
+     */
+    public String getHref() {
+        return _href;
+    }
+
+    /**
+     * Sets the link href.
+     * <p>
+     * @param href the link href, <b>null</b> if none.
+     *
+     */
+    public void setHref(String href) {
+        _href = href;
+    }
+
+    /**
+     * Returns the link title.
+     * <p>
+     * @return the link title, <b>null</b> if none.
+     *
+     */
+    public String getTitle() {
+        return _title;
+    }
+
+    /**
+     * Sets the link title.
+     * <p>
+     * @param title the link title, <b>null</b> if none.
+     *
+     */
+    public void setTitle(String title) {
+        _title = title;
+    }
+
+    /**
+     * Returns the hreflang
+     * <p>
+     * @return Returns the hreflang.
+     */
+    public String getHreflang() {
+        return _hreflang;
+    }
+    
+    /**
+     * Set the hreflang
+     * <p>
+     * @param hreflang The hreflang to set.
+     */
+    public void setHreflang(String hreflang) {
+        _hreflang = hreflang;
+    }
+    
+    /**
+     * Returns the length
+     * <p>
+     * @return Returns the length.
+     */
+    public long getLength() {
+        return _length;
+    }
+    
+    /**
+     * Set the length
+     * <p>
+     * @param length The length to set.
+     */
+    public void setLength(long length) {
+        _length = length;
+    }
+}
Index: src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java
diff -N src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd.impl;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+
+import com.sun.syndication.feed.WireFeed;
+import com.sun.syndication.feed.atom.Category;
+import com.sun.syndication.feed.atom.Content;
+import com.sun.syndication.feed.atom.Entry;
+import com.sun.syndication.feed.atom.Feed;
+import com.sun.syndication.feed.atom.Link;
+import com.sun.syndication.feed.atom.Person;
+import com.sun.syndication.feed.module.impl.ModuleUtils;
+import com.sun.syndication.feed.synd.Converter;
+import com.sun.syndication.feed.synd.SyndCategory;
+import com.sun.syndication.feed.synd.SyndCategoryImpl;
+import com.sun.syndication.feed.synd.SyndContent;
+import com.sun.syndication.feed.synd.SyndContentImpl;
+import com.sun.syndication.feed.synd.SyndEntry;
+import com.sun.syndication.feed.synd.SyndEntryImpl;
+import com.sun.syndication.feed.synd.SyndFeed;
+import com.sun.syndication.feed.synd.SyndLink;
+import com.sun.syndication.feed.synd.SyndLinkImpl;
+
+/**
+ */
+public class ConverterForAtom10 implements Converter {
+    private String _type;
+
+    public ConverterForAtom10() {
+        this("atom_1.0");
+    }
+
+    protected ConverterForAtom10(String type) {
+        _type = type;
+    }
+
+    public String getType() {
+        return _type;
+    }
+
+    public void copyInto(WireFeed feed,SyndFeed syndFeed) {
+        Feed aFeed = (Feed) feed;
+
+        syndFeed.setModules(ModuleUtils.cloneModules(aFeed.getModules()));
+
+        syndFeed.setEncoding(aFeed.getEncoding());
+
+        syndFeed.setUri(aFeed.getId());
+
+        syndFeed.setTitle(aFeed.getTitle());
+
+        String linkHref = null;
+        if (aFeed.getLinks().size() > 0) {
+            linkHref = ((Link) aFeed.getLinks().get(0)).getHref();
+        }
+        syndFeed.setLink(linkHref);
+
+        String aSubtitle = aFeed.getSubtitle();
+        if (aSubtitle!=null) {
+            syndFeed.setDescription(aSubtitle);
+        }
+
+        List aEntries = aFeed.getEntries();
+        if (aEntries!=null) {
+            syndFeed.setEntries(createSyndEntries(aFeed, aEntries));
+        }
+
+        // Core Atom language/author/copyright/modified elements have precedence
+        // over DC equivalent info.
+
+        Person author = aFeed.getAuthor();
+        if (author!=null && author.getName()!=null) {
+            syndFeed.setAuthor(author.getName());
+        }
+
+        String rights = aFeed.getRights();
+        if (rights!=null) {
+            syndFeed.setCopyright(rights);
+        }
+
+        Date date = aFeed.getUpdated();
+        if (date!=null) {
+            syndFeed.setPublishedDate(date);
+        }
+    }
+
+    protected List createSyndEntries(Feed feed, List atomEntries) {
+        List syndEntries = new ArrayList();
+        for (int i=0;i<atomEntries.size();i++) {
+            syndEntries.add(createSyndEntry(feed, (Entry) atomEntries.get(i)));
+        }
+        return syndEntries;
+    }
+
+    protected SyndEntry createSyndEntry(Feed feed, Entry entry) {
+        SyndEntry syndEntry = new SyndEntryImpl();
+        syndEntry.setModules(ModuleUtils.cloneModules(entry.getModules()));
+
+        syndEntry.setTitle(entry.getTitle());
+
+        String id = entry.getId();
+        if (id!=null) {
+            syndEntry.setUri(entry.getId());
+        }
+        else {
+            syndEntry.setUri(syndEntry.getLink());
+        }
+
+        Content content = entry.getContent();
+        if (content!=null) {
+            SyndContent sContent = new SyndContentImpl();
+            sContent.setType(content.getType());
+            sContent.setValue(content.getValue());
+            syndEntry.setDescription(sContent);
+        }
+
+        Content summary = entry.getSummary();
+        if (summary!=null) {
+            SyndContent sSummary = new SyndContentImpl();
+            sSummary.setType(summary.getType());
+            sSummary.setValue(summary.getValue());
+            syndEntry.setSummary(sSummary);
+        }
+
+        Person author = entry.getAuthor();
+        if (author!=null && author.getName()!=null) {
+            syndEntry.setAuthor(author.getName());
+        }
+
+        Date date = entry.getPublished();
+        if (date!=null) {
+            syndEntry.setPublishedDate(date);
+        }
+
+        date = entry.getUpdated();
+        if (date!=null) {
+            syndEntry.setUpdatedDate(date);
+        }
+        
+        List categories = entry.getCategories();
+        if (categories!=null) {
+            List syndCategories = new ArrayList();
+            for (Iterator iter=categories.iterator(); iter.hasNext();) {
+                Category c = (Category)iter.next();
+                SyndCategory syndCategory = new SyndCategoryImpl();
+                syndCategory.setName(c.getTerm()); 
+                syndCategory.setTaxonomyUri(c.getScheme());
+                // TODO: categories MAY have labels 
+                //       syndCategory.setLabel(c.getLabel());
+                syndCategories.add(syndCategory);
+            }
+            syndEntry.setCategories(syndCategories);
+        }
+        
+        List links = entry.getLinks();
+        if (links != null) {
+            List syndLinks = new ArrayList();
+            for (Iterator iter=links.iterator(); iter.hasNext();) {
+                Link link = (Link)iter.next();
+                SyndLink syndLink = new SyndLinkImpl(); 
+                syndLink.setRel(link.getRel());
+                syndLink.setType(link.getType());
+                syndLink.setHref(resolveLink(feed, entry, link.getHref()));
+                syndLink.setHreflang(link.getHreflang());
+                syndLink.setLength(link.getLength());
+                syndLinks.add(syndLink);                
+                // use first alt link found as entry link
+                if (syndEntry.getLink() == null && 
+                      (link.getRel() == null || link.getRel().equals("alternate"))) {
+                   syndEntry.setLink(resolveLink(feed, entry, link.getHref()));
+                }
+            }
+            syndEntry.setLinks(syndLinks);
+        }
+
+        return syndEntry;
+    }
+    
+    /** Use xml:base attributes at feed and entry level to resolve relative links */
+    private String resolveLink(Feed feed, Entry entry, String link) {
+        if (link.startsWith("http://") || link.startsWith("https://")) return link;       
+        StringBuffer sb = new StringBuffer();
+        if (feed != null && feed.getXmlBase() != null) {
+            sb.append(feed.getXmlBase());
+            if (!feed.getXmlBase().endsWith("/")) sb.append("/");
+        }
+        if (entry != null && entry.getXmlBase() != null) {
+            sb.append(entry.getXmlBase());
+            if (!entry.getXmlBase().endsWith("/")) sb.append("/");
+        }
+        sb.append(link);
+        return sb.toString();
+    }
+
+    public WireFeed createRealFeed(SyndFeed syndFeed) {
+        Feed aFeed = new Feed(getType());
+        aFeed.setModules(ModuleUtils.cloneModules(syndFeed.getModules()));
+
+        aFeed.setEncoding(syndFeed.getEncoding());
+
+        aFeed.setId(syndFeed.getUri());
+
+        aFeed.setTitle(syndFeed.getTitle());
+
+        List aLinks = new ArrayList();
+        String sLink = syndFeed.getLink();
+        if (sLink != null) {
+            Link link = new Link();
+            link.setRel("alternate");
+            link.setHref(sLink);
+            aLinks.add(link);
+        }
+        List slinks = syndFeed.getLinks();
+        if (slinks != null) {
+            for (Iterator iter=slinks.iterator(); iter.hasNext();) {       
+                SyndLink syndLink = (SyndLink)iter.next();
+                String rel = syndLink.getRel();
+                if (sLink != null && (rel==null || rel.equals("alternate"))) {
+                    continue; // don't add more than one alterate link
+                }
+                Link link = new Link();
+                link.setRel(syndLink.getRel());
+                link.setHref(syndLink.getHref());
+                link.setHreflang(syndLink.getHreflang());
+                link.setLength(syndLink.getLength());
+                aLinks.add(link);
+            }
+        }
+        if (aLinks.size() > 0) aFeed.setLinks(aLinks);
+        
+        List sCats = syndFeed.getCategories();
+        List aCats = new ArrayList();
+        if (sCats != null) {
+            for (Iterator iter=sCats.iterator(); iter.hasNext();) { 
+                SyndCategory sCat = (SyndCategory)iter.next();
+                Category aCat = new Category();
+                aCat.setTerm(sCat.getName());
+                // TODO: aCat.setLabel(sCat.getLabel());
+                aCat.setScheme(sCat.getTaxonomyUri());
+                aCats.add(aCat);
+            }
+        }
+        if (aCats.size() > 0) aFeed.setCategories(aCats);
+
+        String sDesc = syndFeed.getDescription();
+        if (sDesc!=null) {
+            aFeed.setSubtitle(sDesc);
+        }
+
+        String sAuthor = syndFeed.getAuthor();
+        if (sAuthor!=null) {
+            Person person = new Person();
+            person.setName(sAuthor);
+            aFeed.setAuthor(person);
+        }
+
+        aFeed.setRights(syndFeed.getCopyright());
+
+        aFeed.setUpdated(syndFeed.getPublishedDate());
+
+        List sEntries = syndFeed.getEntries();
+        if (sEntries!=null) {
+            aFeed.setEntries(createAtomEntries(sEntries));
+        }
+
+        return aFeed;
+    }
+
+
+    protected List createAtomEntries(List syndEntries) {
+        List atomEntries = new ArrayList();
+        for (int i=0;i<syndEntries.size();i++) {
+            atomEntries.add(createAtomEntry((SyndEntry)syndEntries.get(i)));
+        }
+        return atomEntries;
+    }
+
+    protected Entry createAtomEntry(SyndEntry sEntry) {
+        Entry aEntry = new Entry();
+        aEntry.setModules(ModuleUtils.cloneModules(sEntry.getModules()));
+
+        aEntry.setId(sEntry.getUri());
+
+        aEntry.setTitle(sEntry.getTitle());
+
+        List aLinks = new ArrayList();
+        String sLink = sEntry.getLink();
+        if (sLink != null) {
+            Link link = new Link();
+            link.setRel("alternate");
+            link.setHref(sLink);
+            aLinks.add(link);
+        }
+        List slinks = sEntry.getLinks();
+        if (slinks != null) {
+            for (Iterator iter=slinks.iterator(); iter.hasNext();) {       
+                SyndLink syndLink = (SyndLink)iter.next();
+                String rel = syndLink.getRel();
+                if (sLink != null && (rel==null || rel.equals("alternate"))) {
+                    continue; // don't add more than one alterate link
+                }
+                Link link = new Link();
+                link.setRel(syndLink.getRel());
+                link.setHref(syndLink.getHref());
+                link.setHreflang(syndLink.getHreflang());
+                link.setLength(syndLink.getLength());
+                aLinks.add(link);
+            }
+        }
+        if (aLinks.size() > 0) aEntry.setLinks(aLinks);
+        
+        List sCats = sEntry.getCategories();
+        List aCats = new ArrayList();
+        if (sCats != null) {
+            for (Iterator iter=sCats.iterator(); iter.hasNext();) { 
+                SyndCategory sCat = (SyndCategory)iter.next();
+                Category aCat = new Category();
+                aCat.setTerm(sCat.getName());
+                // TODO: aCat.setLabel(sCat.getLabel());
+                aCat.setScheme(sCat.getTaxonomyUri());
+                aCats.add(aCat);
+            }
+        }
+        if (aCats.size() > 0) aEntry.setCategories(aCats);
+        
+        SyndContent sDescription = sEntry.getDescription();
+        if (sDescription!=null) {
+            Content content = new Content();
+            content.setType(sDescription.getType());
+            content.setValue(sDescription.getValue());
+            aEntry.setContent(content);
+        }
+
+        SyndContent sSummary = sEntry.getSummary();
+        if (sSummary!=null) {
+            Content summary = new Content();
+            summary.setType(sSummary.getType());
+            summary.setValue(sSummary.getValue());
+            aEntry.setSummary(summary);
+        }
+
+        String sAuthor = sEntry.getAuthor();
+        if (sAuthor!=null) {
+            Person person = new Person();
+            person.setName(sAuthor);
+            aEntry.setAuthor(person);
+        }
+
+        aEntry.setPublished(sEntry.getPublishedDate());
+        aEntry.setUpdated(sEntry.getUpdatedDate()); 
+
+        return aEntry;
+    }
+
+}
Index: src/java/com/sun/syndication/io/impl/Atom10Generator.java
===================================================================
RCS file: src/java/com/sun/syndication/io/impl/Atom10Generator.java
diff -N src/java/com/sun/syndication/io/impl/Atom10Generator.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/io/impl/Atom10Generator.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,378 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.io.impl;
+
+import java.io.StringReader;
+import java.util.Iterator;
+import java.util.List;
+
+import org.jdom.Attribute;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.Namespace;
+import org.jdom.input.SAXBuilder;
+
+import com.sun.syndication.feed.WireFeed;
+import com.sun.syndication.feed.atom.Category;
+import com.sun.syndication.feed.atom.Content;
+import com.sun.syndication.feed.atom.Entry;
+import com.sun.syndication.feed.atom.Feed;
+import com.sun.syndication.feed.atom.Generator;
+import com.sun.syndication.feed.atom.Link;
+import com.sun.syndication.feed.atom.Person;
+import com.sun.syndication.io.FeedException;
+
+/**
+ * Feed Generator for Atom
+ * <p/>
+ *
+ * @author Elaine Chien
+ * @author Dave Johnson (updated for Atom 1.0)
+ *
+ */
+
+public class Atom10Generator extends BaseWireFeedGenerator {
+    private static final String ATOM_URI = "http://www.w3.org/2005/Atom";
+    private static final Namespace ATOM_NS = Namespace.getNamespace(ATOM_URI);
+
+    private String _version;
+
+    public Atom10Generator() {
+        this("atom_1.0","1.0");
+    }
+
+    protected Atom10Generator(String type,String version) {
+        super(type);
+        _version = version;
+    }
+
+    protected String getVersion() {
+        return _version;
+    }
+
+    protected Namespace getFeedNamespace() {
+        return ATOM_NS;
+    }
+
+    public Document generate(WireFeed wFeed) throws FeedException {
+        Feed feed = (Feed) wFeed;
+        Element root = createRootElement(feed);
+        populateFeed(feed,root);
+        return createDocument(root);
+    }
+
+    protected Document createDocument(Element root) {
+        return new Document(root);
+    }
+
+    protected Element createRootElement(Feed feed) {
+        Element root = new Element("feed",getFeedNamespace());
+        root.addNamespaceDeclaration(getFeedNamespace());
+        Attribute version = new Attribute("version", getVersion());
+        root.setAttribute(version);
+        if (feed.getXmlBase() != null) {
+            root.setAttribute("base", feed.getXmlBase(), Namespace.XML_NAMESPACE);
+        }
+        generateModuleNamespaceDefs(root);
+        return root;
+    }
+
+    protected void populateFeed(Feed feed,Element parent) throws FeedException  {
+        addFeed(feed,parent);
+        addEntries(feed,parent);
+    }
+
+    protected void addFeed(Feed feed,Element parent) throws FeedException {
+        Element eFeed = parent;
+        populateFeedHeader(feed,eFeed);
+        checkFeedHeaderConstraints(eFeed);
+        generateFeedModules(feed.getModules(),eFeed);
+    }
+
+    protected void addEntries(Feed feed,Element parent) throws FeedException {
+        List items = feed.getEntries();
+        for (int i=0;i<items.size();i++) {
+            addEntry((Entry)items.get(i),parent);
+        }
+        checkEntriesConstraints(parent);
+    }
+
+    protected void addEntry(Entry entry,Element parent) throws FeedException {
+        Element eEntry = new Element("entry", getFeedNamespace());
+        if (entry.getXmlBase() != null) {
+            eEntry.setAttribute("base", entry.getXmlBase(), Namespace.XML_NAMESPACE);
+        }
+        populateEntry(entry,eEntry);
+        checkEntryConstraints(eEntry);
+        generateItemModules(entry.getModules(),eEntry);
+        parent.addContent(eEntry);
+    }
+
+    protected void populateFeedHeader(Feed feed,Element eFeed) throws FeedException {
+        if (feed.getTitle() != null) {
+            eFeed.addContent(generateSimpleElement("title", feed.getTitle()));
+        }
+
+        List links = feed.getLinks();
+        if (links != null) for (int i = 0; i < links.size(); i++) {
+            eFeed.addContent(generateLinkElement((Link)links.get(i)));
+        }
+
+        List cats = feed.getCategories();
+        if (cats != null) for (Iterator iter=cats.iterator(); iter.hasNext();) {
+            eFeed.addContent(generateCategoryElement((Category)iter.next()));
+        }
+        
+        if (feed.getAuthor() != null) {
+            Element authorElement = new Element("author", getFeedNamespace());
+            fillPersonElement(authorElement, feed.getAuthor());
+            eFeed.addContent(authorElement);
+        }
+
+        List contributors = feed.getContributors();
+        for (int i = 0; i < contributors.size(); i++) {
+            Element contributorElement = new Element("contributor", getFeedNamespace());
+            fillPersonElement(contributorElement, (Person)contributors.get(i));
+            eFeed.addContent(contributorElement);
+        }
+
+        if (feed.getSubtitle() != null) {
+            eFeed.addContent(generateSimpleElement("subtitle", feed.getSubtitle()));
+        }
+
+        if (feed.getId() != null) {
+            eFeed.addContent(generateSimpleElement("id", feed.getId()));
+        }
+
+        if (feed.getGenerator() != null) {
+            eFeed.addContent(generateGeneratorElement(feed.getGenerator()));
+        }
+
+        if (feed.getRights() != null) {
+            eFeed.addContent(generateSimpleElement("rights", feed.getRights()));
+        }
+
+        if (feed.getUpdated() != null) {
+            Element updatedElement = new Element("updated", getFeedNamespace());
+            updatedElement.addContent(DateParser.formatW3CDateTime(feed.getUpdated()));
+            eFeed.addContent(updatedElement);
+        }
+    }
+
+    protected void populateEntry(Entry entry, Element eEntry) throws FeedException {
+        if (entry.getTitle() != null) {
+            eEntry.addContent(generateSimpleElement("title", entry.getTitle()));
+        }
+        List links = entry.getLinks();
+        if (links != null) for (int i = 0; i < links.size(); i++) {
+            eEntry.addContent(generateLinkElement((Link)links.get(i)));
+        }
+
+        List cats = entry.getCategories();
+        if (cats != null) for (Iterator iter=cats.iterator(); iter.hasNext();) {
+            eEntry.addContent(generateCategoryElement((Category)iter.next()));
+        }
+        
+        if (entry.getAuthor() != null) {
+            Element authorElement = new Element("author", getFeedNamespace());
+            fillPersonElement(authorElement, entry.getAuthor());
+            eEntry.addContent(authorElement);
+        }
+
+        List contributors = entry.getContributors();
+        for (int i = 0; i < contributors.size(); i++) {
+            Element contributorElement = new Element("contributor", getFeedNamespace());
+            fillPersonElement(contributorElement, (Person)contributors.get(i));
+            eEntry.addContent(contributorElement);
+        }
+        if (entry.getId() != null) {
+            eEntry.addContent(generateSimpleElement("id", entry.getId()));
+        }
+
+        if (entry.getUpdated() != null) {
+            Element updatedElement = new Element("updated", getFeedNamespace());
+            updatedElement.addContent(DateParser.formatW3CDateTime(entry.getUpdated()));
+            eEntry.addContent(updatedElement);
+        }
+
+        if (entry.getPublished() != null) {
+            Element publishedElement = new Element("published", getFeedNamespace());
+            publishedElement.addContent(DateParser.formatW3CDateTime(entry.getPublished()));
+            eEntry.addContent(publishedElement);
+        }
+
+        if (entry.getContent() != null) {
+            Element contentElement = new Element("content", getFeedNamespace());
+            fillContentElement(contentElement, entry.getContent());
+            eEntry.addContent(contentElement);
+        }
+
+        if (entry.getSummary() != null) {
+            Element summaryElement = new Element("summary", getFeedNamespace());
+            fillContentElement(summaryElement, entry.getSummary());
+            eEntry.addContent(summaryElement);
+        }
+    }
+
+    protected void checkFeedHeaderConstraints(Element eFeed) throws FeedException {
+    }
+
+    protected void checkEntriesConstraints(Element parent) throws FeedException {
+    }
+
+    protected void checkEntryConstraints(Element eEntry) throws FeedException {
+    }
+
+
+    protected Element generateCategoryElement(Category cat) {
+        Element catElement = new Element("category", getFeedNamespace());
+
+        if (cat.getTerm() != null) {
+            Attribute termAttribute = new Attribute("term", cat.getTerm());
+            catElement.setAttribute(termAttribute);
+        }
+
+        if (cat.getLabel() != null) {
+            Attribute labelAttribute = new Attribute("label", cat.getLabel());
+            catElement.setAttribute(labelAttribute);
+        }
+
+        if (cat.getScheme() != null) {
+            Attribute schemeAttribute = new Attribute("scheme", cat.getScheme());
+            catElement.setAttribute(schemeAttribute);
+        }
+        return catElement;
+    }
+
+    protected Element generateLinkElement(Link link) {
+        Element linkElement = new Element("link", getFeedNamespace());
+
+        if (link.getRel() != null) {
+            Attribute relAttribute = new Attribute("rel", link.getRel().toString());
+            linkElement.setAttribute(relAttribute);
+        }
+
+        if (link.getType() != null) {
+            Attribute typeAttribute = new Attribute("type", link.getType());
+            linkElement.setAttribute(typeAttribute);
+        }
+
+        if (link.getHref() != null) {
+            Attribute hrefAttribute = new Attribute("href", link.getHref());
+            linkElement.setAttribute(hrefAttribute);
+        }
+        
+        if (link.getHreflang() != null) {
+            Attribute hreflangAttribute = new Attribute("hreflang", link.getHreflang());
+            linkElement.setAttribute(hreflangAttribute);
+        }
+        return linkElement;
+    }
+
+
+    protected void fillPersonElement(Element element, Person person) {
+        if (person.getName() != null) {
+            element.addContent(generateSimpleElement("name", person.getName()));
+        }
+        if (person.getUri() != null) {
+            element.addContent(generateSimpleElement("uri", person.getUri()));
+        }
+
+        if (person.getEmail() != null) {
+            element.addContent(generateSimpleElement("email", person.getEmail()));
+        }
+    }
+
+    protected Element generateTagLineElement(Content tagline) {
+        Element taglineElement = new Element("subtitle", getFeedNamespace());
+
+        if (tagline.getType() != null) {
+            Attribute typeAttribute = new Attribute("type", tagline.getType());
+            taglineElement.setAttribute(typeAttribute);
+        }
+
+        if (tagline.getValue() != null) {
+            taglineElement.addContent(tagline.getValue());
+        }
+        return taglineElement;
+    }
+
+    protected void fillContentElement(Element contentElement, Content content)
+        throws FeedException {
+
+        String type = content.getType();
+        if (type != null) {
+            Attribute modeAttribute = new Attribute("type", content.getType().toString());
+            contentElement.setAttribute(modeAttribute);
+        }
+
+        if (content.getValue() != null) {
+
+            if (type == null || type.equals(Content.TEXT)) {
+                contentElement.addContent(content.getValue());
+            } else if (type.equals(Content.HTML)) {
+                contentElement.addContent(content.getValue());
+            } else if (type.equals(Content.XHTML)) {
+
+                StringBuffer tmpDocString = new StringBuffer("<tmpdoc>");
+                tmpDocString.append(content.getValue());
+                tmpDocString.append("</tmpdoc>");
+                StringReader tmpDocReader = new StringReader(tmpDocString.toString());
+                Document tmpDoc;
+
+                try {
+                    SAXBuilder saxBuilder = new SAXBuilder();
+                    tmpDoc = saxBuilder.build(tmpDocReader);
+                }
+                catch (Exception ex) {
+                    throw new FeedException("Invalid XML",ex);
+                }
+
+                List children = tmpDoc.getRootElement().removeContent();
+                contentElement.addContent(children);
+            }
+        }
+    }
+
+    protected Element generateGeneratorElement(Generator generator) {
+        Element generatorElement = new Element("generator", getFeedNamespace());
+
+        if (generator.getUrl() != null) {
+            Attribute urlAttribute = new Attribute("url", generator.getUrl());
+            generatorElement.setAttribute(urlAttribute);
+        }
+
+        if (generator.getVersion() != null) {
+            Attribute versionAttribute = new Attribute("version", generator.getVersion());
+            generatorElement.setAttribute(versionAttribute);
+        }
+
+        if (generator.getValue() != null) {
+            generatorElement.addContent(generator.getValue());
+        }
+
+        return generatorElement;
+
+    }
+
+    protected Element generateSimpleElement(String name, String value) {
+        Element element = new Element(name, getFeedNamespace());
+        element.addContent(value);
+        return element;
+    }
+
+}
Index: src/java/com/sun/syndication/io/impl/Atom10Parser.java
===================================================================
RCS file: src/java/com/sun/syndication/io/impl/Atom10Parser.java
diff -N src/java/com/sun/syndication/io/impl/Atom10Parser.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/io/impl/Atom10Parser.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,352 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.io.impl;
+
+import com.sun.syndication.feed.WireFeed;
+import com.sun.syndication.feed.atom.*;
+import com.sun.syndication.io.FeedException;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.Namespace;
+import org.jdom.output.XMLOutputter;
+
+import java.util.*;
+
+/**
+ * @author Dave Johnson (updated for Atom 1.0)
+ */
+public class Atom10Parser extends BaseWireFeedParser {
+    private static final String ATOM_URI = "http://www.w3.org/2005/Atom";
+
+    public Atom10Parser() {
+        this("atom_1.0");
+    }
+
+    protected Atom10Parser(String type) {
+        super(type);
+    }
+
+    protected Namespace getAtomNamespace() {
+        return Namespace.getNamespace(ATOM_URI);
+    }
+
+    public boolean isMyType(Document document) {
+        Element rssRoot = document.getRootElement();
+        Namespace defaultNS = rssRoot.getNamespace();
+        return (defaultNS!=null) && defaultNS.equals(getAtomNamespace());
+    }
+
+    public WireFeed parse(Document document, boolean validate) throws IllegalArgumentException,FeedException {
+        if (validate) {
+            validateFeed(document);
+        }
+        Element rssRoot = document.getRootElement();
+        return parseFeed(rssRoot);
+    }
+
+    protected void validateFeed(Document document) throws FeedException {
+        // TBD
+        // here we have to validate the Feed against a schema or whatever
+        // not sure how to do it
+        // one posibility would be to produce an ouput and attempt to parse it again
+        // with validation turned on.
+        // otherwise will have to check the document elements by hand.
+    }
+
+    protected WireFeed parseFeed(Element eFeed) {
+
+        com.sun.syndication.feed.atom.Feed feed = new com.sun.syndication.feed.atom.Feed(getType());
+
+        String xmlBase = eFeed.getAttributeValue("base", Namespace.XML_NAMESPACE);
+        if (xmlBase != null) {
+            feed.setXmlBase(xmlBase);
+        }
+        
+        Element e = eFeed.getChild("title",getAtomNamespace());
+        if (e!=null) {
+            feed.setTitle(e.getText());
+        }
+
+        List eList = eFeed.getChildren("link",getAtomNamespace());
+        feed.setLinks(parseLinks(eList));
+
+        List cList = eFeed.getChildren("category",getAtomNamespace());
+        feed.setCategories(parseCategories(cList));
+
+        e = eFeed.getChild("author",getAtomNamespace());
+        if (e!=null) {
+            feed.setAuthor(parsePerson(e));
+        }
+
+        eList = eFeed.getChildren("contributor",getAtomNamespace());
+        if (eList.size()>0) {
+            feed.setContributors(parsePersons(eList));
+        }
+
+        e = eFeed.getChild("subtitle",getAtomNamespace());
+        if (e!=null) {
+            feed.setSubtitle(e.getText());
+        }
+
+        e = eFeed.getChild("id",getAtomNamespace());
+        if (e!=null) {
+            feed.setId(e.getText());
+        }
+
+        e = eFeed.getChild("generator",getAtomNamespace());
+        if (e!=null) {
+            Generator gen = new Generator();
+            gen.setValue(e.getText());
+            String att = e.getAttributeValue("url");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+            if (att!=null) {
+                gen.setUrl(att);
+            }
+            att = e.getAttributeValue("version");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+            if (att!=null) {
+                gen.setVersion(att);
+            }
+            feed.setGenerator(gen);
+        }
+
+        e = eFeed.getChild("rights",getAtomNamespace());
+        if (e!=null) {
+            feed.setRights(e.getText());
+        }
+
+        e = eFeed.getChild("icon",getAtomNamespace());
+        if (e!=null) {
+            feed.setIcon(e.getText());
+        }
+
+        e = eFeed.getChild("logo",getAtomNamespace());
+        if (e!=null) {
+            feed.setLogo(e.getText());
+        }
+
+        e = eFeed.getChild("updated",getAtomNamespace());
+        if (e!=null) {
+            feed.setUpdated(DateParser.parseDate(e.getText()));
+        }
+
+        eList = eFeed.getChildren("entry",getAtomNamespace());
+        if (eList.size()>0) {
+            feed.setEntries(parseEntries(eList));
+        }
+
+        feed.setModules(parseFeedModules(eFeed));
+
+        return feed;
+    }
+
+    private Link parseLink(Element eLink) {
+        Link link = new Link();
+        String att = eLink.getAttributeValue("rel");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setRel(att);
+        }
+        att = eLink.getAttributeValue("type");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setType(att);
+        }
+        att = eLink.getAttributeValue("href");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setHref(att);
+        }
+        att = eLink.getAttributeValue("hreflang");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setHreflang(att);
+        }
+        att = eLink.getAttributeValue("length");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setLength(Long.parseLong(att));
+        }
+        return link;
+    }
+
+    // List(Elements) -> List(Link)
+    private List parseLinks(List eLinks) {
+        List links = new ArrayList();
+        for (int i=0;i<eLinks.size();i++) {
+            Element eLink = (Element) eLinks.get(i);
+            links.add(parseLink(eLink));
+        }
+        return (links.size()>0) ? links : null;
+    }
+
+    private Person parsePerson(Element ePerson) {
+        Person person = new Person();
+        Element e = ePerson.getChild("name",getAtomNamespace());
+        if (e!=null) {
+            person.setName(e.getText());
+        }
+        e = ePerson.getChild("uri",getAtomNamespace());
+        if (e!=null) {
+            person.setUri(e.getText());
+        }
+        e = ePerson.getChild("email",getAtomNamespace());
+        if (e!=null) {
+            person.setEmail(e.getText());
+        }
+        return person;
+    }
+
+    // List(Elements) -> List(Persons)
+    private List parsePersons(List ePersons) {
+        List persons = new ArrayList();
+        for (int i=0;i<ePersons.size();i++) {
+            persons.add(parsePerson((Element)ePersons.get(i)));
+        }
+        return (persons.size()>0) ? persons : null;
+    }
+
+    private Content parseContent(Element e) {
+        String value = null;
+        String type = e.getAttributeValue("type");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        type = (type!=null) ? type : Content.TEXT;
+        if (type.equals(Content.TEXT)) {
+            // do nothing XML Parser took care of this
+            value = e.getText();
+        }
+        else if (type.equals(Content.HTML)) {
+            value = e.getText();
+        }
+        else if (type.equals(Content.XHTML)) {
+            XMLOutputter outputter = new XMLOutputter();
+            List eContent = e.getContent();
+            Iterator i = eContent.iterator();
+            while (i.hasNext()) {
+                org.jdom.Content c = (org.jdom.Content) i.next();
+                if (c instanceof Element) {
+                    Element eC = (Element) c;
+                    if (eC.getNamespace().equals(getAtomNamespace())) {
+                        ((Element)c).setNamespace(Namespace.NO_NAMESPACE);
+                    }
+                }
+            }
+            value = outputter.outputString(eContent);
+        }
+        
+        // TODO: handle Atom Content's src attribute
+
+        Content content = new Content();
+        content.setType(type);
+        content.setValue(value);
+        return content;
+    }
+
+    // List(Elements) -> List(Entries)
+    private List parseEntries(List eEntries) {
+        List entries = new ArrayList();
+        for (int i=0;i<eEntries.size();i++) {
+            entries.add(parseEntry((Element)eEntries.get(i)));
+        }
+        return (entries.size()>0) ? entries : null;
+    }
+
+    private Entry parseEntry(Element eEntry) {
+        Entry entry = new Entry();
+
+        String xmlBase = eEntry.getAttributeValue("base", Namespace.XML_NAMESPACE);
+        if (xmlBase != null) {
+            entry.setXmlBase(xmlBase);
+        }
+        
+        Element e = eEntry.getChild("title",getAtomNamespace());
+        if (e!=null) {
+            entry.setTitle(e.getText());
+        }
+
+        List eList = eEntry.getChildren("link",getAtomNamespace());
+        entry.setLinks(parseLinks(eList));
+
+        e = eEntry.getChild("author",getAtomNamespace());
+        if (e!=null) {
+            entry.setAuthor(parsePerson(e));
+        }
+
+        eList = eEntry.getChildren("contributor",getAtomNamespace());
+        if (eList.size()>0) {
+            entry.setContributors(parsePersons(eList));
+        }
+
+        e = eEntry.getChild("id",getAtomNamespace());
+        if (e!=null) {
+            entry.setId(e.getText());
+        }
+
+        e = eEntry.getChild("updated",getAtomNamespace());
+        if (e!=null) {
+            entry.setUpdated(DateParser.parseDate(e.getText()));
+        }
+
+        e = eEntry.getChild("published",getAtomNamespace());
+        if (e!=null) {
+            entry.setPublished(DateParser.parseDate(e.getText()));
+        }
+
+        e = eEntry.getChild("summary",getAtomNamespace());
+        if (e!=null) {
+            entry.setSummary(parseContent(e));
+        }
+
+        e = eEntry.getChild("content",getAtomNamespace());
+        if (e!=null) {
+            entry.setContent(parseContent(e));
+        }
+
+        e = eEntry.getChild("rights",getAtomNamespace());
+        if (e!=null) {
+            entry.setRights(e.getText());
+        }
+
+        List cList = eEntry.getChildren("category",getAtomNamespace());
+        entry.setCategories(parseCategories(cList));
+
+        // TODO: SHOULD handle Atom entry source element
+        
+        entry.setModules(parseItemModules(eEntry));
+
+        return entry;
+    }
+
+    private List parseCategories(List eCategories) {
+        List cats = new ArrayList();
+        for (int i=0;i<eCategories.size();i++) {
+            Element eCategory = (Element) eCategories.get(i);
+            cats.add(parseCategory(eCategory));
+        }
+        return (cats.size()>0) ? cats : null;
+    }
+    
+    private Category parseCategory(Element eCategory) {
+        Category category = new Category();
+        String att = eCategory.getAttributeValue("term");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            category.setTerm(att);
+        }
+        att = eCategory.getAttributeValue("scheme");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            category.setScheme(att);
+        }
+        att = eCategory.getAttributeValue("label");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            category.setLabel(att);
+        }
+        return category;
+
+    }
+}
Index: src/test/com/sun/syndication/unittest/TestOpsAtom10.java
===================================================================
RCS file: src/test/com/sun/syndication/unittest/TestOpsAtom10.java
diff -N src/test/com/sun/syndication/unittest/TestOpsAtom10.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/test/com/sun/syndication/unittest/TestOpsAtom10.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,15 @@
+package com.sun.syndication.unittest;
+
+/**
+ *
+ * <p>
+ * @author Dave Johnson
+ *
+ */
+public class TestOpsAtom10 extends FeedOpsTest {
+
+    public TestOpsAtom10() {
+        super("atom_0.3");
+    }
+
+}
Index: src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java
===================================================================
RCS file: src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java
diff -N src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,77 @@
+/*
+ * Created on Jun 24, 2004
+ *
+ */
+package com.sun.syndication.unittest;
+
+import com.sun.syndication.feed.synd.SyndEntry;
+import com.sun.syndication.feed.synd.SyndContent;
+import com.sun.syndication.io.impl.DateParser;
+
+import java.util.List;
+import java.util.Date;
+
+/**
+ * @author pat
+ * @author Dave Johnson (modified for Atom 1.0)
+ *
+ */
+public class TestSyndFeedAtom10 extends SyndFeedTest {
+
+	public TestSyndFeedAtom10() {
+		super("atom_1.0");
+	}
+
+    protected TestSyndFeedAtom10(String type) {
+        super(type);
+    }
+
+    protected TestSyndFeedAtom10(String feedType,String feedFileName) {
+        super(feedType,feedFileName);
+    }
+
+    public void testTitle() throws Exception {
+        assertProperty(getCachedSyndFeed().getTitle(),"feed.title");
+    }
+
+    public void testLink() throws Exception {
+        assertProperty( getCachedSyndFeed().getLink(),"feed.link^href");
+    }
+
+    public void getAuthor() throws Exception {
+        assertProperty(getCachedSyndFeed().getAuthor(),"feed.author.name");
+    }
+
+    public void testCopyright() throws Exception {
+        assertProperty(getCachedSyndFeed().getCopyright(),"feed.rights");
+    }
+
+    public void testPublishedDate() throws Exception {
+        Date d = DateParser.parseW3CDateTime("2000-01-01T00:00:00Z");
+        assertEquals(getCachedSyndFeed().getPublishedDate(),d);
+    }
+
+
+    protected void _testEntry(int i) throws Exception {
+        List items = getCachedSyndFeed().getEntries();
+        SyndEntry entry = (SyndEntry) items.get(i);
+        assertProperty(entry.getTitle(),"feed.entry["+i+"].title");
+        assertProperty(entry.getLink(),"feed.entry["+i+"].link^href");
+        assertProperty(entry.getAuthor(),"feed.entry["+i+"].author.name");
+        Date d = DateParser.parseW3CDateTime("2000-0"+(i+1)+"-01T00:00:00Z");
+        assertEquals(entry.getPublishedDate(),d);
+        assertProperty(entry.getDescription().getValue(),"feed.entry["+i+"].summary");
+        assertProperty(((SyndContent)entry.getContents().get(0)).getValue(),"feed.entry["+i+"].content[0]");
+        assertProperty(((SyndContent)entry.getContents().get(1)).getValue(),"feed.entry["+i+"].content[1]");
+    }
+
+    public void testEntry0() throws Exception {
+        _testEntry(0);
+    }
+
+    public void testEntry1() throws Exception {
+        _testEntry(1);
+    }
+
+
+}
