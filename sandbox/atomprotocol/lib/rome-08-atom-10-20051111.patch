Index: .cvsignore
===================================================================
RCS file: /cvs/rome/.cvsignore,v
retrieving revision 1.1
diff -u -r1.1 .cvsignore
--- .cvsignore	2 Aug 2004 00:28:21 -0000	1.1
+++ .cvsignore	12 Nov 2005 02:22:16 -0000
@@ -1 +1,7 @@
 target
+nbproject
+classes.eclipse
+bin
+.settings
+.classpath
+.project
Index: src/java/com/sun/syndication/feed/atom/Category.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/atom/Category.java
diff -N src/java/com/sun/syndication/feed/atom/Category.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/atom/Category.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.atom;
+
+import com.sun.syndication.feed.impl.ObjectBean;
+
+import java.io.Serializable;
+
+/**
+ * Bean for category elements of Atom feeds.
+ * <p>
+ * @author Dave Johnson (added for Atom 1.0)
+ */
+public class Category implements Cloneable, Serializable  {
+    
+    private ObjectBean _objBean;
+    
+    private String _term;
+    private String _scheme;  
+    private String _label;
+
+    /**
+     * Default constructor. All properties are set to <b>null</b>.
+     * <p>
+     *
+     */
+    public Category() {
+        _objBean = new ObjectBean(this.getClass(),this);
+    }
+
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public Object clone() throws CloneNotSupportedException {
+        return _objBean.clone();
+    }
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public boolean equals(Object other) {
+        return _objBean.equals(other);
+    }
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public int hashCode() {
+        return _objBean.hashCode();
+    }
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public String toString() {
+        return _objBean.toString();
+    }
+    
+    /** 
+     * Get label for category.
+     * <p>
+     * @return Label for category.
+     */
+    public String getLabel() {
+        return _label;
+    }
+    
+    /**
+     * Set label for category.
+     * <p>
+     * @param Label for category.
+     */
+    public void setLabel(String label) {
+        this._label = label;
+    }
+    
+    /**
+     * Get Scheme URI for category.
+     * <p>
+     * @return Scheme URI for category.
+     */
+    public String getScheme() {
+        return _scheme;
+    }
+    
+    /**
+     * Set scheme URI for category.
+     * <p>
+     * @param Scheme URI for category.
+     */
+    public void setScheme(String scheme) {
+        this._scheme = scheme;
+    }
+    
+    /**
+     * Return term for category.
+     * <p>
+     * @return Term for category.
+     */
+    public String getTerm() {
+        return _term;
+    }
+    
+    /**
+     * Set term for category.
+     * <p>
+     * @param Term for category.
+     */
+    public void setTerm(String term) {
+        this._term = term;
+    }
+}
Index: src/java/com/sun/syndication/feed/synd/SyndLink.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/SyndLink.java
diff -N src/java/com/sun/syndication/feed/synd/SyndLink.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/SyndLink.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd;
+
+/**
+ * Represents a link or enclosure associated with entry.
+ * @author Dave Johnson
+ */
+public interface SyndLink {
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public abstract Object clone() throws CloneNotSupportedException;
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public abstract boolean equals(Object other);
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public abstract int hashCode();
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public abstract String toString();
+
+    /**
+     * Returns the link rel.
+     * <p>
+     * @return the link rel, <b>null</b> if none.
+     *
+     */
+    public abstract String getRel();
+
+    /**
+     * Sets the link rel.
+     * <p>
+     * @param rel the link rel,, <b>null</b> if none.
+     *
+     */
+    public abstract void setRel(String rel);
+
+    /**
+     * Returns the link type.
+     * <p>
+     * @return the link type, <b>null</b> if none.
+     *
+     */
+    public abstract String getType();
+
+    /**
+     * Sets the link type.
+     * <p>
+     * @param type the link type, <b>null</b> if none.
+     *
+     */
+    public abstract void setType(String type);
+
+    /**
+     * Returns the link href.
+     * <p>
+     * @return the link href, <b>null</b> if none.
+     *
+     */
+    public abstract String getHref();
+
+    /**
+     * Sets the link href.
+     * <p>
+     * @param href the link href, <b>null</b> if none.
+     *
+     */
+    public abstract void setHref(String href);
+
+    /**
+     * Returns the link title.
+     * <p>
+     * @return the link title, <b>null</b> if none.
+     *
+     */
+    public abstract String getTitle();
+
+    /**
+     * Sets the link title.
+     * <p>
+     * @param title the link title, <b>null</b> if none.
+     *
+     */
+    public abstract void setTitle(String title);
+
+    /**
+     * Returns the hreflang
+     * <p>
+     * @return Returns the hreflang.
+     */
+    public abstract String getHreflang();
+
+    /**
+     * Set the hreflang
+     * <p>
+     * @param hreflang The hreflang to set.
+     */
+    public abstract void setHreflang(String hreflang);
+
+    /**
+     * Returns the length
+     * <p>
+     * @return Returns the length.
+     */
+    public abstract long getLength();
+
+    /**
+     * Set the length
+     * <p>
+     * @param length The length to set.
+     */
+    public abstract void setLength(long length);
+}
Index: src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java
diff -N src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/SyndLinkImpl.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd;
+
+import com.sun.syndication.feed.impl.ObjectBean;
+
+import java.io.Serializable;
+
+/**
+ * Represents a link or an enclosure.
+ * <p>
+ * @author Alejandro Abdelnur
+ * @author Dave Johnson (updated for Atom 1.0)
+ */
+public class SyndLinkImpl implements Cloneable,Serializable, SyndLink {
+    
+    private ObjectBean _objBean;
+    
+    private String _href;
+    private String _rel;
+    private String _type;
+    private String _hreflang; 
+    private String _title;
+    private long   _length;  
+
+    /**
+     * Default constructor. All properties are set to <b>null</b>.
+     * <p>
+     *
+     */
+    public SyndLinkImpl() {
+        _objBean = new ObjectBean(this.getClass(),this);
+    }
+
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public Object clone() throws CloneNotSupportedException {
+        return _objBean.clone();
+    }
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public boolean equals(Object other) {
+        return _objBean.equals(other);
+    }
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public int hashCode() {
+        return _objBean.hashCode();
+    }
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public String toString() {
+        return _objBean.toString();
+    }
+
+    /**
+     * Returns the link rel.
+     * <p>
+     * @return the link rel, <b>null</b> if none.
+     *
+     */
+    public String getRel() {
+        return _rel;
+    }
+
+    /**
+     * Sets the link rel.
+     * <p>
+     * @param rel the link rel,, <b>null</b> if none.
+     *
+     */
+    public void setRel(String rel) {
+        //TODO add check, ask P@ about the check
+        _rel = rel;
+    }
+
+    /**
+     * Returns the link type.
+     * <p>
+     * @return the link type, <b>null</b> if none.
+     *
+     */
+    public String getType() {
+        return _type;
+    }
+
+    /**
+     * Sets the link type.
+     * <p>
+     * @param type the link type, <b>null</b> if none.
+     *
+     */
+    public void setType(String type) {
+        _type = type;
+    }
+
+    /**
+     * Returns the link href.
+     * <p>
+     * @return the link href, <b>null</b> if none.
+     *
+     */
+    public String getHref() {
+        return _href;
+    }
+
+    /**
+     * Sets the link href.
+     * <p>
+     * @param href the link href, <b>null</b> if none.
+     *
+     */
+    public void setHref(String href) {
+        _href = href;
+    }
+
+    /**
+     * Returns the link title.
+     * <p>
+     * @return the link title, <b>null</b> if none.
+     *
+     */
+    public String getTitle() {
+        return _title;
+    }
+
+    /**
+     * Sets the link title.
+     * <p>
+     * @param title the link title, <b>null</b> if none.
+     *
+     */
+    public void setTitle(String title) {
+        _title = title;
+    }
+
+    /**
+     * Returns the hreflang
+     * <p>
+     * @return Returns the hreflang.
+     */
+    public String getHreflang() {
+        return _hreflang;
+    }
+    
+    /**
+     * Set the hreflang
+     * <p>
+     * @param hreflang The hreflang to set.
+     */
+    public void setHreflang(String hreflang) {
+        _hreflang = hreflang;
+    }
+    
+    /**
+     * Returns the length
+     * <p>
+     * @return Returns the length.
+     */
+    public long getLength() {
+        return _length;
+    }
+    
+    /**
+     * Set the length
+     * <p>
+     * @param length The length to set.
+     */
+    public void setLength(long length) {
+        _length = length;
+    }
+}
Index: src/java/com/sun/syndication/feed/synd/SyndPerson.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/SyndPerson.java
diff -N src/java/com/sun/syndication/feed/synd/SyndPerson.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/SyndPerson.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd;
+
+
+
+
+/**
+ * Bean interface for authors and contributors of SyndFeedImpl feeds and entries.
+ * <p>
+ * @author Dave Johnson
+ *
+ */
+public interface SyndPerson extends Cloneable {
+
+    /**
+     * Returns  name of person
+     */
+    public String getName();
+    
+    /**
+     * Sets name of person.
+     */
+    public void setName(String name);
+    
+    /**
+     * Returns URI of person.
+     */
+    public String getUri();
+    
+    /** 
+     * Sets URI of person.
+     */
+    public void setUri(String uri);
+    
+    /** 
+     * Returns email of person.
+     */
+    public String getEmail();
+    
+    /**
+     * Sets email of person.
+     */
+    public void setEmail(String email);
+    
+    
+    /**
+     * Creates a deep clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public Object clone() throws CloneNotSupportedException;
+
+}
Index: src/java/com/sun/syndication/feed/synd/SyndPersonImpl.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/SyndPersonImpl.java
diff -N src/java/com/sun/syndication/feed/synd/SyndPersonImpl.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/SyndPersonImpl.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd;
+
+import com.sun.syndication.feed.impl.ObjectBean;
+import com.sun.syndication.feed.module.DCSubjectImpl;
+import com.sun.syndication.feed.module.DCSubject;
+
+import java.util.AbstractList;
+import java.util.List;
+import java.util.ArrayList;
+import java.io.Serializable;
+
+/**
+ * Bean for authors and contributors of SyndFeedImpl feeds and entries.
+ * <p>
+ * @author Dave Johnson
+ *
+ */
+public class SyndPersonImpl implements Serializable, SyndPerson {
+    private ObjectBean _objBean;
+    private String _name;
+    private String _uri;
+    private String _email;
+
+    /**
+     * For implementations extending SyndContentImpl to be able to use the ObjectBean functionality
+     * with extended interfaces.
+     */
+    public SyndPersonImpl() {
+        _objBean = new ObjectBean(SyndPerson.class,this);
+    }
+
+    /**
+     * Creates a deep 'bean' clone of the object.
+     * <p>
+     * @return a clone of the object.
+     * @throws CloneNotSupportedException thrown if an element of the object cannot be cloned.
+     *
+     */
+    public Object clone() throws CloneNotSupportedException {
+        return _objBean.clone();
+    }
+
+    /**
+     * Indicates whether some other object is "equal to" this one as defined by the Object equals() method.
+     * <p>
+     * @param other he reference object with which to compare.
+     * @return <b>true</b> if 'this' object is equal to the 'other' object.
+     *
+     */
+    public boolean equals(Object other) {
+        return _objBean.equals(other);
+    }
+
+    /**
+     * Returns a hashcode value for the object.
+     * <p>
+     * It follows the contract defined by the Object hashCode() method.
+     * <p>
+     * @return the hashcode of the bean object.
+     *
+     */
+    public int hashCode() {
+        return _objBean.hashCode();
+    }
+
+    /**
+     * Returns the String representation for the object.
+     * <p>
+     * @return String representation for the object.
+     *
+     */
+    public String toString() {
+        return _objBean.toString();
+    }
+
+    /**
+     * Returns the person name.
+     * <p>
+     * @return the person name, <b>null</b> if none.
+     *
+     */
+    public String getName() {
+        return _name;
+    }
+
+    /**
+     * Sets the category name.
+     * <p>
+     * @param name the category name to set, <b>null</b> if none.
+     *
+     */
+    public void setName(String name) {
+        _name = name;
+    }
+
+    /**
+     * Returns the person's e-mail address.
+     * <p>
+     * @return the person's e-mail address, <b>null</b> if none.
+     *
+     */
+    public String getEmail() {
+        return _email;
+    }
+
+    /**
+     * Sets the person's e-mail address.
+     * <p>
+     * @param email The person's e-mail address to set, <b>null</b> if none.
+     *
+     */
+    public void setEmail(String email) {
+        _email = email;
+    }
+    
+    /**
+     * Returns the person's URI.
+     * <p>
+     * @return the person's URI, <b>null</b> if none.
+     *
+     */
+    public String getUri() {
+        return _uri;
+    }
+
+    /**
+     * Sets the person's URI.
+     * <p>
+     * @param uri the peron's URI to set, <b>null</b> if none.
+     *
+     */
+    public void setUri(String uri) {
+        _uri = uri;
+    }
+}
Index: src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java
===================================================================
RCS file: src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java
diff -N src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/feed/synd/impl/ConverterForAtom10.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,404 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.feed.synd.impl;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+
+import com.sun.syndication.feed.WireFeed;
+import com.sun.syndication.feed.atom.Category;
+import com.sun.syndication.feed.atom.Content;
+import com.sun.syndication.feed.atom.Entry;
+import com.sun.syndication.feed.atom.Feed;
+import com.sun.syndication.feed.atom.Link;
+import com.sun.syndication.feed.atom.Person;
+import com.sun.syndication.feed.module.impl.ModuleUtils;
+import com.sun.syndication.feed.synd.Converter;
+import com.sun.syndication.feed.synd.SyndCategory;
+import com.sun.syndication.feed.synd.SyndCategoryImpl;
+import com.sun.syndication.feed.synd.SyndContent;
+import com.sun.syndication.feed.synd.SyndContentImpl;
+import com.sun.syndication.feed.synd.SyndEntry;
+import com.sun.syndication.feed.synd.SyndEntryImpl;
+import com.sun.syndication.feed.synd.SyndFeed;
+import com.sun.syndication.feed.synd.SyndLink;
+import com.sun.syndication.feed.synd.SyndLinkImpl;
+
+/**
+ */
+public class ConverterForAtom10 implements Converter {
+    private String _type;
+
+    public ConverterForAtom10() {
+        this("atom_1.0");
+    }
+
+    protected ConverterForAtom10(String type) {
+        _type = type;
+    }
+
+    public String getType() {
+        return _type;
+    }
+
+    public void copyInto(WireFeed feed, SyndFeed syndFeed) {
+        Feed aFeed = (Feed) feed;
+
+        syndFeed.setModules(ModuleUtils.cloneModules(aFeed.getModules()));
+
+        syndFeed.setEncoding(aFeed.getEncoding());
+
+        syndFeed.setUri(aFeed.getId());
+
+        syndFeed.setTitle(aFeed.getTitle());
+
+        Content aSubtitle = aFeed.getSubtitle();
+        if (aSubtitle!=null) {
+            syndFeed.setDescription(aSubtitle.getValue());
+        }
+
+        // if there is exactly one alternate link, use that as THE link
+        if (aFeed.getAlternateLinks() != null 
+                && aFeed.getAlternateLinks().size() == 1) {
+            Link theLink = (Link)aFeed.getAlternateLinks().get(0);
+            syndFeed.setLink(theLink.getHref());
+        }
+        // lump alternate and other links together
+        List syndLinks = new ArrayList();
+        if (aFeed.getAlternateLinks() != null 
+                && aFeed.getAlternateLinks().size() > 0) {
+            syndLinks.add(createSyndLinks(aFeed.getAlternateLinks()));
+        }
+        if (aFeed.getOtherLinks() != null 
+                && aFeed.getOtherLinks().size() > 0) {
+            syndLinks.add(createSyndLinks(aFeed.getOtherLinks()));
+        }
+            
+        List aEntries = aFeed.getEntries();
+        if (aEntries!=null) {
+            syndFeed.setEntries(createSyndEntries(aFeed, aEntries));
+        }
+
+        // Core Atom language/author/copyright/modified elements have precedence
+        // over DC equivalent info.
+
+        List authors = aFeed.getAuthors();
+        if (authors!=null && authors.size() > 0) {
+            syndFeed.setAuthors(ConverterForAtom03.createSyndPersons(authors));
+        }
+
+        String rights = aFeed.getRights();
+        if (rights!=null) {
+            syndFeed.setCopyright(rights);
+        }
+
+        Date date = aFeed.getUpdated();
+        if (date!=null) {
+            syndFeed.setPublishedDate(date);
+        }
+    }
+
+    protected List createSyndLinks(List aLinks) {
+        ArrayList sLinks = new ArrayList();
+        for (Iterator iter = aLinks.iterator(); iter.hasNext();) {
+            Link link = (Link)iter.next();
+            SyndLink sLink = new SyndLinkImpl();
+            sLink.setHref(     link.getHref());
+            sLink.setType(     link.getType());
+            sLink.setLength(   link.getLength());
+            sLink.setHreflang( link.getHref());
+            sLinks.add(sLink);
+        }
+        return sLinks;
+    }
+    
+    protected List createSyndEntries(Feed feed, List atomEntries) {
+        List syndEntries = new ArrayList();
+        for (int i=0;i<atomEntries.size();i++) {
+            syndEntries.add(createSyndEntry(feed, (Entry) atomEntries.get(i)));
+        }
+        return syndEntries;
+    }
+
+    protected SyndEntry createSyndEntry(Feed feed, Entry entry) {
+        SyndEntry syndEntry = new SyndEntryImpl();
+        syndEntry.setModules(ModuleUtils.cloneModules(entry.getModules()));
+
+        syndEntry.setTitle(entry.getTitle());
+
+        String id = entry.getId();
+        if (id!=null) {
+            syndEntry.setUri(entry.getId());
+        }
+        else {
+            syndEntry.setUri(syndEntry.getLink());
+        }
+
+        List contents = entry.getContents();
+        if (contents != null && contents.size() > 0) {
+            List sContents = new ArrayList();
+            for (Iterator iter=contents.iterator(); iter.hasNext();) {
+                Content content = (Content)iter.next();
+                sContents.add(createSyndContent(content));
+            }
+            syndEntry.setContents(sContents);
+        }
+
+        Content summary = entry.getSummary();
+        if (summary!=null) {
+            syndEntry.setDescription(createSyndContent(entry.getSummary()));
+        }
+
+        List authors = entry.getAuthors();
+        if (authors!=null && authors.size() > 0) {
+            syndEntry.setAuthors(ConverterForAtom03.createSyndPersons(authors));
+        }
+
+        Date date = entry.getPublished();
+        if (date!=null) {
+            syndEntry.setPublishedDate(date);
+        }
+
+        date = entry.getUpdated();
+        if (date!=null) {
+            syndEntry.setUpdatedDate(date);
+        }
+        
+        List categories = entry.getCategories();
+        if (categories!=null) {
+            List syndCategories = new ArrayList();
+            for (Iterator iter=categories.iterator(); iter.hasNext();) {
+                Category c = (Category)iter.next();
+                SyndCategory syndCategory = new SyndCategoryImpl();
+                syndCategory.setName(c.getTerm()); 
+                syndCategory.setTaxonomyUri(c.getScheme());
+                // TODO: categories MAY have labels 
+                //       syndCategory.setLabel(c.getLabel());
+                syndCategories.add(syndCategory);
+            }
+            syndEntry.setCategories(syndCategories);
+        }
+                
+        // if there is exactly one alternate link, use that as THE link
+        if (entry.getAlternateLinks() != null 
+                && entry.getAlternateLinks().size() == 1) {
+            Link theLink = (Link)entry.getAlternateLinks().get(0);
+            syndEntry.setLink(theLink.getHref());
+        }
+
+        // lump alternate and other links together
+        List syndLinks = new ArrayList();
+        if (entry.getAlternateLinks() != null 
+                && entry.getAlternateLinks().size() > 0) {
+            syndLinks.add(createSyndLinks(entry.getAlternateLinks()));
+        }
+        if (entry.getOtherLinks() != null 
+                && entry.getOtherLinks().size() > 0) {
+            syndLinks.add(createSyndLinks(entry.getOtherLinks()));
+        }
+        syndEntry.setLinks(syndLinks);
+
+        return syndEntry;
+    }
+    
+    public SyndLink createSyndLink(Feed feed, Entry entry, Link link) {
+        SyndLink syndLink = new SyndLinkImpl(); 
+        syndLink.setRel(link.getRel());
+        syndLink.setType(link.getType());
+        syndLink.setHref(link.getHref());
+        syndLink.setHreflang(link.getHreflang());
+        syndLink.setLength(link.getLength());
+        return syndLink;
+    }
+    
+    public WireFeed createRealFeed(SyndFeed syndFeed) {
+        Feed aFeed = new Feed(getType());
+        aFeed.setModules(ModuleUtils.cloneModules(syndFeed.getModules()));
+
+        aFeed.setEncoding(syndFeed.getEncoding());
+
+        aFeed.setId(syndFeed.getUri());
+
+        aFeed.setTitle(syndFeed.getTitle());
+
+        // separate SyndEntry's links collection into alternate and other links
+        List alternateLinks = new ArrayList();
+        List otherLinks = new ArrayList();
+        String sLink = syndFeed.getLink();
+        List slinks = syndFeed.getLinks();
+        if (slinks != null) {
+            for (Iterator iter=slinks.iterator(); iter.hasNext();) {       
+                SyndLink syndLink = (SyndLink)iter.next();                
+                Link link = new Link();
+                link.setRel(syndLink.getRel());
+                link.setHref(syndLink.getHref());
+                link.setHreflang(syndLink.getHreflang());
+                link.setLength(syndLink.getLength());                
+                if ("alternate".equals(syndLink.getRel())) {
+                    alternateLinks.add(link);
+                } else {
+                    otherLinks.add(link);
+                }
+            }
+        }
+        // no alternate link? then use THE link if there is one
+        if (alternateLinks.size() == 0 && syndFeed.getLink() != null) {
+            Link link = new Link();
+            link.setRel("alternate");
+            link.setHref(syndFeed.getLink());
+            alternateLinks.add(link);
+        }
+        if (alternateLinks.size() > 0) aFeed.setAlternateLinks(alternateLinks);
+        if (otherLinks.size() > 0) aFeed.setOtherLinks(otherLinks);
+        
+        List sCats = syndFeed.getCategories();
+        List aCats = new ArrayList();
+        if (sCats != null) {
+            for (Iterator iter=sCats.iterator(); iter.hasNext();) { 
+                SyndCategory sCat = (SyndCategory)iter.next();
+                Category aCat = new Category();
+                aCat.setTerm(sCat.getName());
+                // TODO: aCat.setLabel(sCat.getLabel());
+                aCat.setScheme(sCat.getTaxonomyUri());
+                aCats.add(aCat);
+            }
+        }
+        if (aCats.size() > 0) aFeed.setCategories(aCats);
+
+        String sDesc = syndFeed.getDescription();
+        if (sDesc != null) {
+            Content subtitle = new Content();
+            subtitle.setType(Content.TEXT); // TODO: need content type in SyndFeed 
+            subtitle.setValue(sDesc);
+            aFeed.setSubtitle(subtitle);
+        }
+
+        List authors = syndFeed.getAuthors();
+        if (authors!=null && authors.size() > 0) {
+            aFeed.setAuthors(ConverterForAtom03.createAtomPersons(authors));
+        }
+
+        aFeed.setRights(syndFeed.getCopyright());
+
+        aFeed.setUpdated(syndFeed.getPublishedDate());
+
+        List sEntries = syndFeed.getEntries();
+        if (sEntries!=null) {
+            aFeed.setEntries(createAtomEntries(sEntries));
+        }
+
+        return aFeed;
+    }
+
+    protected SyndContent createSyndContent(Content content) {
+        SyndContent sContent = new SyndContentImpl();
+        sContent.setType(content.getType());
+        sContent.setValue(content.getValue());
+        return sContent;
+    }
+
+    protected List createAtomEntries(List syndEntries) {
+        List atomEntries = new ArrayList();
+        for (int i=0;i<syndEntries.size();i++) {
+            atomEntries.add(createAtomEntry((SyndEntry)syndEntries.get(i)));
+        }
+        return atomEntries;
+    }
+
+    protected Entry createAtomEntry(SyndEntry sEntry) {
+        Entry aEntry = new Entry();
+        aEntry.setModules(ModuleUtils.cloneModules(sEntry.getModules()));
+
+        aEntry.setId(sEntry.getUri());
+
+        aEntry.setTitle(sEntry.getTitle());
+
+        // separate SyndEntry's links collection into alternate and other links
+        List alternateLinks = new ArrayList();
+        List otherLinks = new ArrayList();
+        List slinks = sEntry.getLinks();
+        if (slinks != null) {
+            for (Iterator iter=slinks.iterator(); iter.hasNext();) {       
+                SyndLink syndLink = (SyndLink)iter.next();                
+                Link link = new Link();
+                link.setRel(syndLink.getRel());
+                link.setHref(syndLink.getHref());
+                link.setHreflang(syndLink.getHreflang());
+                link.setLength(syndLink.getLength());                
+                if ("alternate".equals(syndLink.getRel())) {
+                    alternateLinks.add(link);
+                } else {
+                    otherLinks.add(link);
+                }
+            }
+        }
+        // no alternate link? then use THE link if there is one
+        if (alternateLinks.size() == 0 && sEntry.getLink() != null) {
+            Link link = new Link();
+            link.setRel("alternate");
+            link.setHref(sEntry.getLink());
+            alternateLinks.add(link);
+        }
+        if (alternateLinks.size() > 0) aEntry.setAlternateLinks(alternateLinks);
+        if (otherLinks.size() > 0) aEntry.setOtherLinks(otherLinks);
+       
+        List sCats = sEntry.getCategories();
+        List aCats = new ArrayList();
+        if (sCats != null) {
+            for (Iterator iter=sCats.iterator(); iter.hasNext();) { 
+                SyndCategory sCat = (SyndCategory)iter.next();
+                Category aCat = new Category();
+                aCat.setTerm(sCat.getName());
+                // TODO: aCat.setLabel(sCat.getLabel());
+                aCat.setScheme(sCat.getTaxonomyUri());
+                aCats.add(aCat);
+            }
+        }
+        if (aCats.size() > 0) aEntry.setCategories(aCats);
+        
+        SyndContent sDescription = sEntry.getDescription();
+        if (sDescription!=null) {
+            Content summary = new Content();
+            summary.setType(sDescription.getType());
+            summary.setValue(sDescription.getValue());
+            aEntry.setSummary(summary);
+        }
+
+        // take first item in contents collection as the content 
+        List syndContents = sEntry.getContents();
+        if (syndContents != null && syndContents.size() > 0) {
+            SyndContent syndContent = (SyndContent)syndContents.get(0);
+            Content content = new Content();
+            content.setType(syndContent.getType());
+            content.setValue(syndContent.getValue());
+            aEntry.setSummary(content);
+        }
+
+        List authors = sEntry.getAuthors();
+        if (authors!=null && authors.size() > 0) {
+            aEntry.setAuthors(ConverterForAtom03.createAtomPersons(authors));
+        }
+
+        aEntry.setPublished(sEntry.getPublishedDate());
+        aEntry.setUpdated(sEntry.getUpdatedDate()); 
+
+        return aEntry;
+    }
+
+}
Index: src/java/com/sun/syndication/io/impl/Atom10Generator.java
===================================================================
RCS file: src/java/com/sun/syndication/io/impl/Atom10Generator.java
diff -N src/java/com/sun/syndication/io/impl/Atom10Generator.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/io/impl/Atom10Generator.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,397 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.io.impl;
+
+import java.io.StringReader;
+import java.util.Iterator;
+import java.util.List;
+
+import org.jdom.Attribute;
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.Namespace;
+import org.jdom.input.SAXBuilder;
+
+import com.sun.syndication.feed.WireFeed;
+import com.sun.syndication.feed.atom.Category;
+import com.sun.syndication.feed.atom.Content;
+import com.sun.syndication.feed.atom.Entry;
+import com.sun.syndication.feed.atom.Feed;
+import com.sun.syndication.feed.atom.Generator;
+import com.sun.syndication.feed.atom.Link;
+import com.sun.syndication.feed.atom.Person;
+import com.sun.syndication.io.FeedException;
+
+/**
+ * Feed Generator for Atom
+ * <p/>
+ *
+ * @author Elaine Chien
+ * @author Dave Johnson (updated for Atom 1.0)
+ *
+ */
+
+public class Atom10Generator extends BaseWireFeedGenerator {
+    private static final String ATOM_10_URI = "http://www.w3.org/2005/Atom";
+    private static final Namespace ATOM_NS = Namespace.getNamespace(ATOM_10_URI);
+
+    private String _version;
+
+    public Atom10Generator() {
+        this("atom_1.0","1.0");
+    }
+
+    protected Atom10Generator(String type,String version) {
+        super(type);
+        _version = version;
+    }
+
+    protected String getVersion() {
+        return _version;
+    }
+
+    protected Namespace getFeedNamespace() {
+        return ATOM_NS;
+    }
+
+    public Document generate(WireFeed wFeed) throws FeedException {
+        Feed feed = (Feed) wFeed;
+        Element root = createRootElement(feed);
+        populateFeed(feed,root);
+        return createDocument(root);
+    }
+
+    protected Document createDocument(Element root) {
+        return new Document(root);
+    }
+
+    protected Element createRootElement(Feed feed) {
+        Element root = new Element("feed",getFeedNamespace());
+        root.addNamespaceDeclaration(getFeedNamespace());
+        Attribute version = new Attribute("version", getVersion());
+        root.setAttribute(version);
+        if (feed.getXmlBase() != null) {
+            root.setAttribute("base", feed.getXmlBase(), Namespace.XML_NAMESPACE);
+        }
+        generateModuleNamespaceDefs(root);
+        return root;
+    }
+
+    protected void populateFeed(Feed feed,Element parent) throws FeedException  {
+        addFeed(feed,parent);
+        addEntries(feed,parent);
+    }
+
+    protected void addFeed(Feed feed,Element parent) throws FeedException {
+        Element eFeed = parent;
+        populateFeedHeader(feed,eFeed);
+        checkFeedHeaderConstraints(eFeed);
+        generateFeedModules(feed.getModules(),eFeed);
+    }
+
+    protected void addEntries(Feed feed,Element parent) throws FeedException {
+        List items = feed.getEntries();
+        for (int i=0;i<items.size();i++) {
+            addEntry((Entry)items.get(i),parent);
+        }
+        checkEntriesConstraints(parent);
+    }
+
+    protected void addEntry(Entry entry,Element parent) throws FeedException {
+        Element eEntry = new Element("entry", getFeedNamespace());
+        if (entry.getXmlBase() != null) {
+            eEntry.setAttribute("base", entry.getXmlBase(), Namespace.XML_NAMESPACE);
+        }
+        populateEntry(entry,eEntry);
+        checkEntryConstraints(eEntry);
+        generateItemModules(entry.getModules(),eEntry);
+        parent.addContent(eEntry);
+    }
+
+    protected void populateFeedHeader(Feed feed,Element eFeed) throws FeedException {
+        if (feed.getTitle() != null) {
+            eFeed.addContent(generateSimpleElement("title", feed.getTitle()));
+        }
+
+        List links = feed.getAlternateLinks();
+        if (links != null) for (int i = 0; i < links.size(); i++) {
+            eFeed.addContent(generateLinkElement((Link)links.get(i)));
+        }
+        links = feed.getOtherLinks();
+        if (links != null) for (int i = 0; i < links.size(); i++) {
+            eFeed.addContent(generateLinkElement((Link)links.get(i)));
+        }
+
+        List cats = feed.getCategories();
+        if (cats != null) for (Iterator iter=cats.iterator(); iter.hasNext();) {
+            eFeed.addContent(generateCategoryElement((Category)iter.next()));
+        }
+        
+        if (feed.getAuthors()!=null && feed.getAuthors().size() > 0) {
+            for (Iterator iter = feed.getAuthors().iterator(); iter.hasNext(); ) {
+                Element authorElement = new Element("author", getFeedNamespace());
+                fillPersonElement(authorElement, (Person)feed.getAuthors().get(0));
+                eFeed.addContent(authorElement);
+            }
+        }
+
+        List contributors = feed.getContributors();
+        for (int i = 0; i < contributors.size(); i++) {
+            Element contributorElement = new Element("contributor", getFeedNamespace());
+            fillPersonElement(contributorElement, (Person)contributors.get(i));
+            eFeed.addContent(contributorElement);
+        }
+
+        if (feed.getSubtitle() != null) {
+            eFeed.addContent(
+                generateSimpleElement("subtitle", feed.getSubtitle().getValue()));
+        }
+
+        if (feed.getId() != null) {
+            eFeed.addContent(generateSimpleElement("id", feed.getId()));
+        }
+
+        if (feed.getGenerator() != null) {
+            eFeed.addContent(generateGeneratorElement(feed.getGenerator()));
+        }
+
+        if (feed.getRights() != null) {
+            eFeed.addContent(generateSimpleElement("rights", feed.getRights()));
+        }
+
+        if (feed.getUpdated() != null) {
+            Element updatedElement = new Element("updated", getFeedNamespace());
+            updatedElement.addContent(DateParser.formatW3CDateTime(feed.getUpdated()));
+            eFeed.addContent(updatedElement);
+        }
+    }
+
+    protected void populateEntry(Entry entry, Element eEntry) throws FeedException {
+        if (entry.getTitle() != null) {
+            eEntry.addContent(generateSimpleElement("title", entry.getTitle()));
+        }
+        List links = entry.getAlternateLinks();
+        if (links != null) for (int i = 0; i < links.size(); i++) {
+            eEntry.addContent(generateLinkElement((Link)links.get(i)));
+        }
+        links = entry.getOtherLinks();
+        if (links != null) for (int i = 0; i < links.size(); i++) {
+            eEntry.addContent(generateLinkElement((Link)links.get(i)));
+        }
+
+        List cats = entry.getCategories();
+        if (cats != null) for (Iterator iter=cats.iterator(); iter.hasNext();) {
+            eEntry.addContent(generateCategoryElement((Category)iter.next()));
+        }
+        
+        if (entry.getAuthors()!=null && entry.getAuthors().size() > 0) {
+            for (Iterator iter = entry.getAuthors().iterator(); iter.hasNext(); ) {
+                Element authorElement = new Element("author", getFeedNamespace());
+                fillPersonElement(authorElement, (Person)entry.getAuthors().get(0));
+                eEntry.addContent(authorElement);            
+            }
+        }
+
+        List contributors = entry.getContributors();
+        for (int i = 0; i < contributors.size(); i++) {
+            Element contributorElement = new Element("contributor", getFeedNamespace());
+            fillPersonElement(contributorElement, (Person)contributors.get(i));
+            eEntry.addContent(contributorElement);
+        }
+        if (entry.getId() != null) {
+            eEntry.addContent(generateSimpleElement("id", entry.getId()));
+        }
+
+        if (entry.getUpdated() != null) {
+            Element updatedElement = new Element("updated", getFeedNamespace());
+            updatedElement.addContent(DateParser.formatW3CDateTime(entry.getUpdated()));
+            eEntry.addContent(updatedElement);
+        }
+
+        if (entry.getPublished() != null) {
+            Element publishedElement = new Element("published", getFeedNamespace());
+            publishedElement.addContent(DateParser.formatW3CDateTime(entry.getPublished()));
+            eEntry.addContent(publishedElement);
+        }
+
+        if (entry.getContents() != null && entry.getContents().size() > 0) {
+            Element contentElement = new Element("content", getFeedNamespace());
+            Content content = (Content)entry.getContents().get(0);
+            fillContentElement(contentElement, content);
+            eEntry.addContent(contentElement);
+        }
+
+        if (entry.getSummary() != null) {
+            Element summaryElement = new Element("summary", getFeedNamespace());
+            fillContentElement(summaryElement, entry.getSummary());
+            eEntry.addContent(summaryElement);
+        }
+    }
+
+    protected void checkFeedHeaderConstraints(Element eFeed) throws FeedException {
+    }
+
+    protected void checkEntriesConstraints(Element parent) throws FeedException {
+    }
+
+    protected void checkEntryConstraints(Element eEntry) throws FeedException {
+    }
+
+
+    protected Element generateCategoryElement(Category cat) {
+        Element catElement = new Element("category", getFeedNamespace());
+
+        if (cat.getTerm() != null) {
+            Attribute termAttribute = new Attribute("term", cat.getTerm());
+            catElement.setAttribute(termAttribute);
+        }
+
+        if (cat.getLabel() != null) {
+            Attribute labelAttribute = new Attribute("label", cat.getLabel());
+            catElement.setAttribute(labelAttribute);
+        }
+
+        if (cat.getScheme() != null) {
+            Attribute schemeAttribute = new Attribute("scheme", cat.getScheme());
+            catElement.setAttribute(schemeAttribute);
+        }
+        return catElement;
+    }
+
+    protected Element generateLinkElement(Link link) {
+        Element linkElement = new Element("link", getFeedNamespace());
+
+        if (link.getRel() != null) {
+            Attribute relAttribute = new Attribute("rel", link.getRel().toString());
+            linkElement.setAttribute(relAttribute);
+        }
+
+        if (link.getType() != null) {
+            Attribute typeAttribute = new Attribute("type", link.getType());
+            linkElement.setAttribute(typeAttribute);
+        }
+
+        if (link.getHref() != null) {
+            Attribute hrefAttribute = new Attribute("href", link.getHref());
+            linkElement.setAttribute(hrefAttribute);
+        }
+        
+        if (link.getHreflang() != null) {
+            Attribute hreflangAttribute = new Attribute("hreflang", link.getHreflang());
+            linkElement.setAttribute(hreflangAttribute);
+        }
+        return linkElement;
+    }
+
+
+    protected void fillPersonElement(Element element, Person person) {
+        if (person.getName() != null) {
+            element.addContent(generateSimpleElement("name", person.getName()));
+        }
+        if (person.getUri() != null) {
+            element.addContent(generateSimpleElement("uri", person.getUri()));
+        }
+
+        if (person.getEmail() != null) {
+            element.addContent(generateSimpleElement("email", person.getEmail()));
+        }
+    }
+
+    protected Element generateTagLineElement(Content tagline) {
+        Element taglineElement = new Element("subtitle", getFeedNamespace());
+
+        if (tagline.getType() != null) {
+            Attribute typeAttribute = new Attribute("type", tagline.getType());
+            taglineElement.setAttribute(typeAttribute);
+        }
+
+        if (tagline.getValue() != null) {
+            taglineElement.addContent(tagline.getValue());
+        }
+        return taglineElement;
+    }
+
+    protected void fillContentElement(Element contentElement, Content content)
+        throws FeedException {
+
+        String type = content.getType();
+        if (type != null) {
+            Attribute typeAttribute = new Attribute("type", type);
+            contentElement.setAttribute(typeAttribute);
+        }
+        String href = content.getSrc();
+        if (href != null) {
+            Attribute srcAttribute = new Attribute("src", href);
+            contentElement.setAttribute(srcAttribute);
+        }
+
+        if (content.getValue() != null) {
+
+            if (type == null || type.equals(Content.TEXT)) {
+                contentElement.addContent(content.getValue());
+            } else if (type.equals(Content.HTML)) {
+                contentElement.addContent(content.getValue());
+            } else if (type.equals(Content.XHTML)) {
+
+                StringBuffer tmpDocString = new StringBuffer("<tmpdoc>");
+                tmpDocString.append(content.getValue());
+                tmpDocString.append("</tmpdoc>");
+                StringReader tmpDocReader = new StringReader(tmpDocString.toString());
+                Document tmpDoc;
+
+                try {
+                    SAXBuilder saxBuilder = new SAXBuilder();
+                    tmpDoc = saxBuilder.build(tmpDocReader);
+                }
+                catch (Exception ex) {
+                    throw new FeedException("Invalid XML",ex);
+                }
+
+                List children = tmpDoc.getRootElement().removeContent();
+                contentElement.addContent(children);
+            }
+        }
+    }
+
+    protected Element generateGeneratorElement(Generator generator) {
+        Element generatorElement = new Element("generator", getFeedNamespace());
+
+        if (generator.getUrl() != null) {
+            Attribute urlAttribute = new Attribute("url", generator.getUrl());
+            generatorElement.setAttribute(urlAttribute);
+        }
+
+        if (generator.getVersion() != null) {
+            Attribute versionAttribute = new Attribute("version", generator.getVersion());
+            generatorElement.setAttribute(versionAttribute);
+        }
+
+        if (generator.getValue() != null) {
+            generatorElement.addContent(generator.getValue());
+        }
+
+        return generatorElement;
+
+    }
+
+    protected Element generateSimpleElement(String name, String value) {
+        Element element = new Element(name, getFeedNamespace());
+        element.addContent(value);
+        return element;
+    }
+
+}
Index: src/java/com/sun/syndication/io/impl/Atom10Parser.java
===================================================================
RCS file: src/java/com/sun/syndication/io/impl/Atom10Parser.java
diff -N src/java/com/sun/syndication/io/impl/Atom10Parser.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/com/sun/syndication/io/impl/Atom10Parser.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,447 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.sun.syndication.io.impl;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.jdom.Document;
+import org.jdom.Element;
+import org.jdom.Namespace;
+import org.jdom.output.XMLOutputter;
+
+import com.sun.syndication.feed.WireFeed;
+import com.sun.syndication.feed.atom.Category;
+import com.sun.syndication.feed.atom.Content;
+import com.sun.syndication.feed.atom.Entry;
+import com.sun.syndication.feed.atom.Feed;
+import com.sun.syndication.feed.atom.Generator;
+import com.sun.syndication.feed.atom.Link;
+import com.sun.syndication.feed.atom.Person;
+import com.sun.syndication.io.FeedException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import org.jdom.Attribute;
+import org.jdom.Parent;
+
+/**
+ * @author Dave Johnson (updated for Atom 1.0)
+ */
+public class Atom10Parser extends BaseWireFeedParser {
+    private static final String ATOM_10_URI = "http://www.w3.org/2005/Atom";
+    Namespace ns = Namespace.getNamespace("http://www.w3.org/2005/Atom");
+
+    public Atom10Parser() {
+        this("atom_1.0");
+    }
+
+    protected Atom10Parser(String type) {
+        super(type);
+    }
+
+    protected Namespace getAtomNamespace() {
+        return Namespace.getNamespace(ATOM_10_URI);
+    }
+
+    public boolean isMyType(Document document) {
+        Element rssRoot = document.getRootElement();
+        Namespace defaultNS = rssRoot.getNamespace();
+        return (defaultNS!=null) && defaultNS.equals(getAtomNamespace());
+    }
+
+    public WireFeed parse(Document document, boolean validate) 
+        throws IllegalArgumentException,FeedException {
+        if (validate) {
+            validateFeed(document);
+        }
+        Element rssRoot = document.getRootElement();
+        return parseFeed(rssRoot);
+    }
+
+    protected void validateFeed(Document document) throws FeedException {
+        // TBD
+        // here we have to validate the Feed against a schema or whatever
+        // not sure how to do it
+        // one posibility would be to produce an ouput and attempt to parse it again
+        // with validation turned on.
+        // otherwise will have to check the document elements by hand.
+    }
+
+    protected WireFeed parseFeed(Element eFeed) {
+
+        com.sun.syndication.feed.atom.Feed feed = 
+            new com.sun.syndication.feed.atom.Feed(getType());
+        
+        URL baseURI = findBaseURI(eFeed);
+
+        String xmlBase = eFeed.getAttributeValue("base", Namespace.XML_NAMESPACE);
+        if (xmlBase != null) {
+            feed.setXmlBase(xmlBase);
+        }
+        
+        Element e = eFeed.getChild("title",getAtomNamespace());
+        if (e!=null) {
+            feed.setTitle(e.getText());
+        }
+
+        List eList = eFeed.getChildren("link",getAtomNamespace());
+        feed.setAlternateLinks(parseAlternateLinks(feed, null, baseURI, eList));
+        feed.setAlternateLinks(parseOtherLinks(feed, null, baseURI, eList));
+
+        List cList = eFeed.getChildren("category",getAtomNamespace());
+        feed.setCategories(parseCategories(baseURI, cList));
+
+        eList = eFeed.getChildren("author", getAtomNamespace());
+        if (eList.size()>0) {
+            feed.setAuthors(parsePersons(baseURI, eList));
+        }
+
+        eList = eFeed.getChildren("contributor",getAtomNamespace());
+        if (eList.size()>0) {
+            feed.setContributors(parsePersons(baseURI, eList));
+        }
+
+        e = eFeed.getChild("subtitle",getAtomNamespace());
+        if (e!=null) {
+            Content subtitle = new Content();
+            subtitle.setType(Content.TEXT); // TODO: need content type of SyndFeed level
+            subtitle.setValue(e.getText());
+            feed.setSubtitle(subtitle);
+        }
+
+        e = eFeed.getChild("id",getAtomNamespace());
+        if (e!=null) {
+            feed.setId(e.getText());
+        }
+
+        e = eFeed.getChild("generator",getAtomNamespace());
+        if (e!=null) {
+            Generator gen = new Generator();
+            gen.setValue(e.getText());
+            String att = e.getAttributeValue("url");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+            if (att!=null) {
+                gen.setUrl(att);
+            }
+            att = e.getAttributeValue("version");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+            if (att!=null) {
+                gen.setVersion(att);
+            }
+            feed.setGenerator(gen);
+        }
+
+        e = eFeed.getChild("rights",getAtomNamespace());
+        if (e!=null) {
+            feed.setRights(e.getText());
+        }
+
+        e = eFeed.getChild("icon",getAtomNamespace());
+        if (e!=null) {
+            feed.setIcon(e.getText());
+        }
+
+        e = eFeed.getChild("logo",getAtomNamespace());
+        if (e!=null) {
+            feed.setLogo(e.getText());
+        }
+
+        e = eFeed.getChild("updated",getAtomNamespace());
+        if (e!=null) {
+            feed.setUpdated(DateParser.parseDate(e.getText()));
+        }
+
+        eList = eFeed.getChildren("entry",getAtomNamespace());
+        if (eList.size()>0) {
+            feed.setEntries(parseEntries(feed, baseURI, eList));
+        }
+
+        feed.setModules(parseFeedModules(eFeed));
+
+        return feed;
+    }
+
+    private Link parseLink(Feed feedbaseURI , Entry entry, URL baseURI, Element eLink) {
+        Link link = new Link();
+        String att = eLink.getAttributeValue("rel");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setRel(att);
+        }
+        att = eLink.getAttributeValue("type");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setType(att);
+        }
+        att = eLink.getAttributeValue("href");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setHref(resolveURI(baseURI, eLink, att));
+        }
+        att = eLink.getAttributeValue("hreflang");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setHreflang(att);
+        }
+        att = eLink.getAttributeValue("length");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            link.setLength(Long.parseLong(att));
+        }
+        return link;
+    }
+
+    // List(Elements) -> List(Link)
+    private List parseAlternateLinks(Feed feed, Entry entry, URL baseURI, List eLinks) {
+        List links = new ArrayList();
+        for (int i=0;i<eLinks.size();i++) {
+            Element eLink = (Element) eLinks.get(i);
+            Link link = parseLink(feed, entry, baseURI, eLink);
+            if (link.getRel() == null 
+                    || "".equals(link.getRel().trim()) 
+                    || "alternate".equals(link.getRel())) {
+                links.add(link);
+            }
+        }
+        return (links.size()>0) ? links : null;
+    }
+
+    private List parseOtherLinks(Feed feed, Entry entry, URL baseURI, List eLinks) {
+        List links = new ArrayList();
+        for (int i=0;i<eLinks.size();i++) {
+            Element eLink = (Element) eLinks.get(i);
+            Link link = parseLink(feed, entry, baseURI, eLink);
+            if (!"alternate".equals(link.getRel())) {
+                links.add(link);
+            }
+        }
+        return (links.size()>0) ? links : null;
+    }
+
+    private Person parsePerson(URL baseURI, Element ePerson) {
+        Person person = new Person();
+        Element e = ePerson.getChild("name",getAtomNamespace());
+        if (e!=null) {
+            person.setName(e.getText());
+        }
+        e = ePerson.getChild("uri",getAtomNamespace());
+        if (e!=null) {
+            person.setUri(resolveURI(baseURI, ePerson, e.getText()));
+        }
+        e = ePerson.getChild("email",getAtomNamespace());
+        if (e!=null) {
+            person.setEmail(e.getText());
+        }
+        return person;
+    }
+
+    // List(Elements) -> List(Persons)
+    private List parsePersons(URL baseURI, List ePersons) {
+        List persons = new ArrayList();
+        for (int i=0;i<ePersons.size();i++) {
+            persons.add(parsePerson(baseURI, (Element)ePersons.get(i)));
+        }
+        return (persons.size()>0) ? persons : null;
+    }
+
+    private Content parseContent(Element e) {
+        String value = null;
+        String type = e.getAttributeValue("type");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        type = (type!=null) ? type : Content.TEXT;
+        if (type.equals(Content.TEXT)) {
+            // do nothing XML Parser took care of this
+            value = e.getText();
+        }
+        else if (type.equals(Content.HTML)) {
+            value = e.getText();
+        }
+        else if (type.equals(Content.XHTML)) {
+            XMLOutputter outputter = new XMLOutputter();
+            List eContent = e.getContent();
+            Iterator i = eContent.iterator();
+            while (i.hasNext()) {
+                org.jdom.Content c = (org.jdom.Content) i.next();
+                if (c instanceof Element) {
+                    Element eC = (Element) c;
+                    if (eC.getNamespace().equals(getAtomNamespace())) {
+                        ((Element)c).setNamespace(Namespace.NO_NAMESPACE);
+                    }
+                }
+            }
+            value = outputter.outputString(eContent);
+        }
+        
+        // TODO: handle Atom Content's src attribute
+
+        Content content = new Content();
+        content.setType(type);
+        content.setValue(value);
+        return content;
+    }
+
+    // List(Elements) -> List(Entries)
+    private List parseEntries(Feed feed, URL baseURI, List eEntries) {
+        List entries = new ArrayList();
+        for (int i=0;i<eEntries.size();i++) {
+            entries.add(parseEntry(feed, (Element)eEntries.get(i), baseURI));
+        }
+        return (entries.size()>0) ? entries : null;
+    }
+
+    private Entry parseEntry(Feed feed, Element eEntry, URL baseURI) {
+        Entry entry = new Entry();
+
+        String xmlBase = eEntry.getAttributeValue("base", Namespace.XML_NAMESPACE);
+        if (xmlBase != null) {
+            entry.setXmlBase(xmlBase);
+        }
+        
+        Element e = eEntry.getChild("title",getAtomNamespace());
+        if (e!=null) {
+            entry.setTitle(e.getText());
+        }
+
+        List eList = eEntry.getChildren("link",getAtomNamespace());
+        entry.setAlternateLinks(parseAlternateLinks(feed, entry, baseURI, eList));
+        entry.setOtherLinks(parseOtherLinks(feed, entry, baseURI, eList));
+
+        eList = eEntry.getChildren("author", getAtomNamespace());
+        if (eList.size()>0) {
+            entry.setAuthors(parsePersons(baseURI, eList));
+        }
+
+        eList = eEntry.getChildren("contributor",getAtomNamespace());
+        if (eList.size()>0) {
+            entry.setContributors(parsePersons(baseURI, eList));
+        }
+
+        e = eEntry.getChild("id",getAtomNamespace());
+        if (e!=null) {
+            entry.setId(e.getText());
+        }
+
+        e = eEntry.getChild("updated",getAtomNamespace());
+        if (e!=null) {
+            entry.setUpdated(DateParser.parseDate(e.getText()));
+        }
+
+        e = eEntry.getChild("published",getAtomNamespace());
+        if (e!=null) {
+            entry.setPublished(DateParser.parseDate(e.getText()));
+        }
+
+        e = eEntry.getChild("summary",getAtomNamespace());
+        if (e!=null) {
+            entry.setSummary(parseContent(e));
+        }
+
+        e = eEntry.getChild("content",getAtomNamespace());
+        if (e!=null) {
+            List contents = new ArrayList();
+            contents.add(parseContent(e));
+            entry.setContents(contents);
+        }
+
+        e = eEntry.getChild("rights",getAtomNamespace());
+        if (e!=null) {
+            entry.setRights(e.getText());
+        }
+
+        List cList = eEntry.getChildren("category",getAtomNamespace());
+        entry.setCategories(parseCategories(baseURI, cList));
+
+        // TODO: SHOULD handle Atom entry source element
+        
+        entry.setModules(parseItemModules(eEntry));
+
+        return entry;
+    }
+
+    private List parseCategories(URL baseURI, List eCategories) {
+        List cats = new ArrayList();
+        for (int i=0;i<eCategories.size();i++) {
+            Element eCategory = (Element) eCategories.get(i);
+            cats.add(parseCategory(baseURI, eCategory));
+        }
+        return (cats.size()>0) ? cats : null;
+    }
+    
+    private Category parseCategory(URL baseURI, Element eCategory) {
+        Category category = new Category();
+        String att = eCategory.getAttributeValue("term");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            category.setTerm(att);
+        }
+        att = eCategory.getAttributeValue("scheme");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            category.setScheme(resolveURI(baseURI, eCategory, att));
+        }
+        att = eCategory.getAttributeValue("label");//getAtomNamespace()); DONT KNOW WHY DOESN'T WORK
+        if (att!=null) {
+            category.setLabel(att);
+        }
+        return category;
+
+    }
+
+    /** Use xml:base attributes at feed and entry level to resolve relative links */
+    private String resolveURI(URL baseURI, Parent parent, String url) {
+        url = (url.equals(".") || url.equals("./")) ? "" : url;
+        if (isRelativeURI(url) && parent != null && parent instanceof Element) {
+            Attribute baseAtt = ((Element)parent).getAttribute("base", Namespace.XML_NAMESPACE);
+            String xmlBase = (baseAtt == null) ? "" : baseAtt.getValue();
+            if (!isRelativeURI(xmlBase) && !xmlBase.endsWith("/")) {
+                xmlBase = xmlBase.substring(0, xmlBase.lastIndexOf("/")+1);
+            }
+            return resolveURI(baseURI, parent.getParent(), xmlBase + url);
+        } else if (isRelativeURI(url) && parent == null) {
+            return baseURI + url;
+        } else if (baseURI != null && url.startsWith("/")) {
+            String hostURI = baseURI.getProtocol() + "://" + baseURI.getHost();
+            if (baseURI.getPort() != baseURI.getDefaultPort()) {
+                hostURI = hostURI + ":" + baseURI.getPort();
+            }
+            return hostURI + url;
+        }
+        return url;
+    }
+    private boolean isRelativeURI(String uri) {
+        if (  uri.startsWith("http://")
+           || uri.startsWith("https://")
+           || uri.startsWith("/")) {
+            return false;
+        }
+        return true;
+    }
+    /** Use feed links and/or xml:base attribute to determine baseURI of feed */
+    private URL findBaseURI(Element root) {
+        URL baseURI = null;
+        List linksList = root.getChildren("link", ns);
+        if (linksList != null) {
+            for (Iterator links = linksList.iterator(); links.hasNext(); ) {
+                Element link = (Element)links.next();
+                if (!root.equals(link.getParent())) break;
+                String href = link.getAttribute("href").getValue();
+                if (   link.getAttribute("rel", ns) == null
+                    || link.getAttribute("rel", ns).getValue().equals("alternate")) {
+                    href = resolveURI(null, link, href);
+                    try {
+                        baseURI = new URL(href);
+                        break;
+                    } catch (MalformedURLException e) {
+                        System.err.println("Base URI is malformed: " + href);
+                    }
+                }
+            }
+        }
+        return baseURI;
+    } 
+}
Index: src/test/com/sun/syndication/unittest/TestOpsAtom10.java
===================================================================
RCS file: src/test/com/sun/syndication/unittest/TestOpsAtom10.java
diff -N src/test/com/sun/syndication/unittest/TestOpsAtom10.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/test/com/sun/syndication/unittest/TestOpsAtom10.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,15 @@
+package com.sun.syndication.unittest;
+
+/**
+ *
+ * <p>
+ * @author Dave Johnson
+ *
+ */
+public class TestOpsAtom10 extends FeedOpsTest {
+
+    public TestOpsAtom10() {
+        super("atom_0.3");
+    }
+
+}
Index: src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java
===================================================================
RCS file: src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java
diff -N src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/test/com/sun/syndication/unittest/TestSyndFeedAtom10.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,77 @@
+/*
+ * Created on Jun 24, 2004
+ *
+ */
+package com.sun.syndication.unittest;
+
+import com.sun.syndication.feed.synd.SyndEntry;
+import com.sun.syndication.feed.synd.SyndContent;
+import com.sun.syndication.io.impl.DateParser;
+
+import java.util.List;
+import java.util.Date;
+
+/**
+ * @author pat
+ * @author Dave Johnson (modified for Atom 1.0)
+ *
+ */
+public class TestSyndFeedAtom10 extends SyndFeedTest {
+
+	public TestSyndFeedAtom10() {
+		super("atom_1.0");
+	}
+
+    protected TestSyndFeedAtom10(String type) {
+        super(type);
+    }
+
+    protected TestSyndFeedAtom10(String feedType,String feedFileName) {
+        super(feedType,feedFileName);
+    }
+
+    public void testTitle() throws Exception {
+        assertProperty(getCachedSyndFeed().getTitle(),"feed.title");
+    }
+
+    public void testLink() throws Exception {
+        assertProperty( getCachedSyndFeed().getLink(),"feed.link^href");
+    }
+
+    public void getAuthor() throws Exception {
+        assertProperty(getCachedSyndFeed().getAuthor(),"feed.author.name");
+    }
+
+    public void testCopyright() throws Exception {
+        assertProperty(getCachedSyndFeed().getCopyright(),"feed.rights");
+    }
+
+    public void testPublishedDate() throws Exception {
+        Date d = DateParser.parseW3CDateTime("2000-01-01T00:00:00Z");
+        assertEquals(getCachedSyndFeed().getPublishedDate(),d);
+    }
+
+
+    protected void _testEntry(int i) throws Exception {
+        List items = getCachedSyndFeed().getEntries();
+        SyndEntry entry = (SyndEntry) items.get(i);
+        assertProperty(entry.getTitle(),"feed.entry["+i+"].title");
+        assertProperty(entry.getLink(),"feed.entry["+i+"].link^href");
+        assertProperty(entry.getAuthor(),"feed.entry["+i+"].author.name");
+        Date d = DateParser.parseW3CDateTime("2000-0"+(i+1)+"-01T00:00:00Z");
+        assertEquals(entry.getPublishedDate(),d);
+        assertProperty(entry.getDescription().getValue(),"feed.entry["+i+"].summary");
+        assertProperty(((SyndContent)entry.getContents().get(0)).getValue(),"feed.entry["+i+"].content[0]");
+        assertProperty(((SyndContent)entry.getContents().get(1)).getValue(),"feed.entry["+i+"].content[1]");
+    }
+
+    public void testEntry0() throws Exception {
+        _testEntry(0);
+    }
+
+    public void testEntry1() throws Exception {
+        _testEntry(1);
+    }
+
+
+}
